{
  "route": "framework/user/en/python-api/hooks",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/python-api/hooks",
  "title": "hooks",
  "content": "Hooks allow you to \"hook\" into functionality and events of core parts of the Frappe Framework. This page documents all of the hooks provided by the framework.\n\n Jump to list of all available hooks in Frappe.\n\nHow does hooks work?\n\nHooks are places in the core code that allow an app to override the standard implementation or extend it. Hooks are defined in hooks.py of your app.\n\nLet's learn by example. Add the following hooks in your app's hooks.py.\n\ntest_string = \"value\"\ntest_list = [\"value\"]\ntest_dict = {\n \"key\": \"value\"\n}\n\nNow, open the python console by running the command bench --site sitename console and run the following lines:\n\nâ¯ bench --site sitename console\nApps in this namespace:\nfrappe, frappe_docs\n\nIn [1]: frappe.get_hooks(\"test_string\")\nOut[1]: [\"value\"]\n\nIn [2]: frappe.get_hooks(\"test_dict\")\nOut[2]: {\"key\": [\"value\"]}\n\nIn [3]: frappe.get_hooks(\"test_list\")\nOut[3]: [\"value\"]\n\nWhen you call frappe.get_hooks, it will convert all the values in a list. This means that if the hook is defined in multiple apps, the values will be collected from those apps. This is what enables the cascading nature of hooks.\n\nNow, the hook value can be consumed in different ways. For example, for including JS assets using app_include_js, all of the values are included. But for overriding whitelisted method, the last value in the list is used.\n\nSo the implementation of the hook is totally dependent on how the author of the feature intended it to be used.\n\nHow are conflicting hooks resolved?\n\nHooks are resolved using \"last writer wins\" strategy. Last installed app on site will have highest priority over others.\n\nWhen the hook overrides existing behaviour like overriding a class then only overrides from last app will work.\nWhen the hook extends behaviour then extensions will be applied in order of installation on the site.\n\n If you need to change this order you can do so by going to \"Installed Applications\" page and clicking on \"Update Hooks Resolution Order\"\n\nApp Meta Data\n\nThese are automatically generated when you create a new app. Most of the time you don't need to change anything here.\n\napp_name - slugified name of the app\napp_title - presentable app name\napp_publisher\napp_description\napp_version\napp_icon\napp_color\n\nJavascript / CSS Assets\n\nThe following hooks allow you to inject static JS and CSS assets in various parts of your site.\n\nDesk\n\nThese hooks allow you to inject JS / CSS in desk.html which renders the Desk.\n\n# injected in desk.html\napp_include_js = \"assets/js/app.min.js\"\napp_include_css = \"assets/js/app.min.css\"\n\n# All of the above support a list of paths too\napp_include_js = [\"assets/js/app1.min.js\", \"assets/js/app2.min.js\"]\n\nPortal\n\nThese hooks allow you to inject JS / CSS in web.html which renders the Portal.\n\n# injected in the web.html\nweb_include_js = \"assets/js/app-web.min.js\"\nweb_include_css = \"assets/js/app-web.min.css\"\n# All of the above support a list of paths too\nweb_include_js = [\"assets/js/web1.min.js\", \"assets/js/web2.min.js\"]\n\nWeb Form\n\nThese hooks allow you to add inject static JS and CSS assets in web_form.html which is used to render Web Forms. These will work only for Standard Web Forms.\n\nwebform_include_js = {\"ToDo\": \"public/js/custom_todo.js\"}\nwebform_include_css = {\"ToDo\": \"public/css/custom_todo.css\"}\n\n For user created Web Forms, you can directly write the script in the form > itself.\n\nPage\n\nThese hooks allow you to inject JS assets in Standard Desk Pages.\n\npage_js = {\"page_name\" : \"public/js/file.js\"}\n\nFor e.g., Background Jobs is a standard page that is part of Core module in Frappe Framework. To add custom behaviour in that page you can add a JS file in your custom app custom_app/public/js/custom_background_jobs.js and add the following line in your hooks file.\n\ncustom_app/hooks.py\n\npage_js = {\"background_jobs\": \"public/js/custom_background_jobs.js\"}\n\nSounds\n\nFrappe ships with a set of audio notifications for events like a success action, document submission, error, etc. You can add your own sounds using the sounds hook.\n\napp/hooks.py\n\nsounds = [\n {\"name\": \"ping\", \"src\": \"/assets/app/sounds/ping.mp3\", \"volume\": 0.2}\n]\n\nYou can play your added sound using the client utility method:\n\nfrappe.utils.play_sound(\"ping\")\n\nInstall Hooks\n\nThese hooks allow you to run code before and after installation of your app. For example, ERPNext has these defined.\n\n# python module path\nbefore_install = \"app.setup.install.before_install\"\nafter_install = \"app.setup.install.after_install\"\nafter_sync = \"app.setup.install.after_sync\"\n\napp/setup/install.py\n\n# will run before app is installed on site\ndef before_install():\n pass\n\n# will run after app is installed on site\ndef after_install():\n pass\n\n# will run after app fixtures are synced\ndef after_sync():\n pass\n\nUninstall Hooks\n\nThese hooks allow you to run code before and after uninstallation of your app.\n\napp/hooks.py\n\nbefore_uninstall = \"app.setup.uninstall.before_uninstall\"\nafter_uninstall = \"app.setup.uninstall.after_uninstall\"\n\napp/setup/uninstall.py\n\n# will run before app is uninstalled from site\ndef before_uninstall():\n pass\n\n# will run after app is uninstalled from site\ndef after_uninstall():\n pass\n\nMigrate Hooks\n\nThese hooks allow you to run code before and after a migration is run on your site via the command bench --site sitename migrate.\n\napp/hooks.py\n\nbefore_migrate = \"app.migrate.before_migrate\"\nafter_migrate = \"app.migrate.after_migrate\"\n\napp/migrate.py\n\ndef after_migrate():\n # run code after site migration\n pass\n\nTest Hooks\n\nThis hook allows you to run code before tests are run on a site. You can use this hook to add seed data to your database which will be available to your tests.\n\napp/hooks.py\n\nbefore_tests = \"app.tests.before_tests\"\n\napp/migrate.py\n\ndef before_tests():\n # add seed data to the database\n pass\n\nFile Hooks\n\nThese hooks allows you to change the implementation of handling user uploaded files.\n\napp/hooks.py\n\nbefore_write_file = \"app.overrides.file.before_write\"\nwrite_file = \"app.overrides.file.write_file\"\ndelete_file_data_content = \"app.overrides.file.delete_file\"\n\napp/overrides/file.py\n\n# will run before file is written to disk\ndef before_write():\n pass\n\n# will override the implementation of writing file to disk\n# can be used to upload files to a CDN instead of writing\n# the file to disk\ndef write_file():\n pass\n\n# will override the implementation of deleting file from disk\n# can be used to delete uploaded files from a CDN instead of\n# deleting file from disk\ndef delete_file():\n pass\n\nEmail Hooks\n\nThese hooks allows you to change the default email module implementation of sending emails and setting default sender address.\n\napp/hooks.py\n\noverride_email_send = \"app.overrides.email.send\"\nget_sender_details = \"app.overrides.email.get_sender_details\"\n\nBy default frappe uses the currently logged in users name and id as sender details on all emails. This can be overriden with get_sender_details hook. And if you want to extend the email modules functionality by using a thirdy party server or app for sending emails then you can use override_email_send hook. This hook will send all the email information (sender, recipient, content(mime)) to a function in custom_app.\n\napp/overrides/email.py\n\n# will be edited as \"John Doe <johndoe@example.com>\"\ndef get_sender_details():\n return \"John Doe\", \"johndoe@example.com\"\n\n# self - EmailQueue object refrence for updating status\ndef send(self, sender, recipient, msg):\n # smtp or http request\n self.update_status(\"Sending\")\n\n Note: You'll have to handle the status change of email queue in your custom app depending on the webhook response you get from your mail provider/server\n\nExtend Bootinfo\n\nAfter a successful login, the Desk is injected with a dictionary of global values called bootinfo. The bootinfo is available as a global object in Javascript as frappe.boot.\n\nThe bootinfo dict contains a lot of values including:\n\nSystem defaults\nNotification status\nPermissions\nUser settings\nLanguage and timezone info\n\nYou can add global values that makes sense for your app via the extend_bootinfo hook.\n\n# python module path\nextend_bootinfo = \"app.boot.boot_session\"\n\nThe method is called with one argument bootinfo, on which you can directly add/update values.\n\napp/boot.py\n\ndef boot_session(bootinfo):\n bootinfo.my_global_key = \"my_global_value\"\n\nNow, you can access the value anywhere in your client side code.\n\nconsole.log(frappe.boot.my_global_key)\n\nWebsite Context\n\nWhen a Portal Page is rendered, a dictionary is built with all of the possible variables that the page might need to render. This dict is also known as context. You can use these hooks to add or modify values in this dict.\n\napp/hooks.py\n\nwebsite_context = {\n \"favicon\": \"/assets/app/image/favicon.png\"\n}\nupdate_website_context = \"app.overrides.website_context\"\n\nThe website_context hook is a simple dict of key value pairs. Use this hook for simple value overrides.\n\nYou can use the update_website_context hook for more complex scenarios as it allows you to manipulate the context dict in a python method. The method is called with one argument, which is the context dict. You can either modify the context directly by mutating it or return a dict that will be merged with context.\n\napp/overrides.py\n\ndef website_context(context):\n context.my_key = \"my_value\"\n\nWebsite Controller Context\n\nFrappe ships with standard web pages like /404 and /about. If you want to extend the controller context for these pages you can use the extend_website_page_controller_context hook.\n\napp/hooks.py\n\nextend_website_page_controller_context = {\n \"frappe.www.404\": \"app.pages.context_404\"\n}\n\nThe above hook configuration will allow you to extend the context of the 404 page so that you can add your own keys or modify existing ones.\n\napp/pages.py\n\ndef context_404(context):\n # context of the 404 page\n context.my_key = \"my_value\"\n\nWeb pages with dynamic routes\n\nDynamic routes are the routes with dynamic values in them.\n\nExample:\n\n/profile/<name>\n\nhere \"name\" is the dynamic part but same profile page is rendered. By default, Frappe supports dynamic routes from documents in \"Web Page\" doctype. To add more dynamic routes, get_web_pages_with_dynamic_routes can be used.\n\napp/hooks.py\n\nget_web_pages_with_dynamic_routes = \"script.get_web_pages_with_dynamic_routes\"\n\nscript.py\n\ndef get_web_pages_with_dynamic_routes():\n return [{\n \"doctype\": \"Custom Web Page\", // Doctype extended from WebsiteGenerator https://frappeframework.com/docs/user/en/guides/portal-development/generators\n \"route\": \"/profile/<name>\",\n \"name\": \"profile-page\" // name of the web view document to render\n }, ...]\n\nWebsite Clear Cache\n\nFrappe Framework caches a lot of static web pages for fast subsequent rendering. If you have created web pages that use cached values, and you want to invalidate the cache, this hook is place to do it.\n\napp/hooks.py\n\nwebsite_clear_cache = \"app.overrides.clear_website_cache\"\n\nThe method is called with one argument path. path is set when cache is being cleared for one route, and is None when cache is cleared for all routes. You need to handle this case if your cache is page specific.\n\napp/overrides.py\n\ndef clear_website_cache(path=None):\n if path:\n # clear page related cache\n else:\n # clear all cache\n\nWebsite Redirects\n\nWebsite Redirects allow you to define redirects from one route to another. Frappe will generate a 304 Redirect response when the source URL is requested and redirect to the target URL. You can redirect plain URLs or you can use regex to match your URLs.\n\napp/hooks.py\n\nwebsite_redirects = [\n {\"source\": \"/compare\", \"target\": \"/comparison\"},\n {\"source\": \"/docs(/.*)?\", \"target\": \"https://docs.tennismart.com/\\1\"},\n {\"source\": r'/items/item\\?item_name=(.*)', \"target\": '/items/\\1', match_with_query_string=True},\n]\n\nThe above configuration will result in following redirects:\n\n/compare to /comparison\n/docs/getting-started to https://docs.tennismart.com/getting-started\n/docs/help to https://docs.tennismart.com/help\n/items/item?item_name=racket to https://docs.tennismart.com/items/racket\n\nWebsite Route Rules\n\nWebsite Route Rules allow you to map URLs to custom controllers. This is commonly used to generate clean URLs for pages.\n\nLet's say you want to have /projects route to display list of projects. This can be done by creating a projects.html and projects.py in www folder.\n\nYou also want to have /project/<name> route to show a project page where name is the dynamic. To do this you can use the website_route_rules hook.\n\napp/hooks.py\n\nwebsite_route_rules = [\n {\"from_route\": \"/projects/<name>\", \"to_route\": \"app/projects/project\"},\n]\n\nNow, you can create your controller files in app/projects folder.\n\napp/projects/project.py\n\ndef get_context(context):\n project_name = frappe.form_dict.name\n project = frappe.get_doc(\"Project\", project_name)\n context.project = project\n\napp/projects/project.html\n\n<h1>{{ project.title }}</h1>\n<p>{{ project.description }}</p>\n\nWebsite Path Resolver\n\nFrappe does some standard route resolving eg. any request to \"/profile\" gets internally converted to \"/me\". website_path_resolver can be used to override this behaviour.\n\napp/hooks.py\n\nwebsite_path_resolver = \"path.to.custom_resolver_method\"\n\nNote: Yourcustom_resolver_method will get the requested route, is expected to return a processed route.\n\nWebsite 404\n\nFrappe renders a default /404 route when a page is not found. You can change this using the website_catch_all hook.\n\napp/hooks.py\n\nwebsite_catch_all = \"not_found\"\n\nThe above configuration will render /not_found when a 404 is occurred. It is upto you to implement the template www/not_found.html and controller www/not_found.py.\n\nDefault Homepage\n\nHomepage is the page which is rendered when you visit the root URL (/) of your site. There are multiple ways to configure what page is rendered as the default homepage.\n\nBy default, the homepage is index. So, frappe will try to render index.html from www folder. This can be overridden using the homepage hook.\n\napp/hooks.py\n\nhomepage = \"homepage\"\n\nThe above configuration will load the www/homepage.html as the default homepage.\n\nYou can also have role based homepage by using the role_home_page hook.\n\napp/hooks.py\n\nrole_home_page = {\n \"Customer\": \"orders\",\n \"Supplier\": \"bills\"\n}\n\nThe above configuration will make /orders the default homepage for users with the Customer role and /bills for users with the Supplier role.\n\nYou can have even more control over the logic by using the get_website_user_home_page hook.\n\napp/hooks.py\n\nget_website_user_home_page = \"app.website.get_home_page\"\n\napp/website.py\n\ndef get_home_page(user):\n if is_projects_user(user):\n return \"projects\"\n if is_partner(user):\n return \"partner-dashboard\"\n return \"index\"\n\n If all of these hooks are defined, the get_website_user_home_page will have > higher priority over the others, and role_home_page will have higher > priority over homepage.\n\nPortal Sidebar\n\nSome Portal views are shown with a sidebar with links to quickly jump to pages. These sidebar items can be customized via hooks.\n\napp/hooks.py\n\nportal_menu_items = [\n {\"title\": \"Dashboard\", \"route\": \"/dashboard\", \"role\": \"Customer\"},\n {\"title\": \"Orders\", \"route\": \"/orders\", \"role\": \"Customer\"},\n]\n\nThe above configuration will add two sidebar links for users with the role Customer.\n\n \n\nThese sidebar items are hardcoded in your app so they are not customizable from Desk. For e.g., if you want to hide a sidebar link temporarily you will have to make changes in your code.\n\nThere is another hook called standard_portal_menu_items which allows you to do that. The sidebar links set in standard_portal_menu_items hook will be synced with the database.\n\napp/hooks.py\n\nstandard_portal_menu_items = [\n {\"title\": \"Dashboard\", \"route\": \"/dashboard\", \"role\": \"Website Manager\"},\n {\"title\": \"Orders\", \"route\": \"/orders\", \"role\": \"Website Manager\"},\n]\n\nThe above configuration will sync sidebar items to the Portal Settings which can later be edited by any System User.\n\n \n\nBrand HTML\n\nThis hook allows you to customize the brand logo in the navbar of your website.\n\napp/hooks.py\n\nbrand_html = '<div><img src=\"tennismart.png\"/> TennisMart</div>'\n\nIf the brand_html is defined, it will override the default brand html in the navbar. It is not recommended to use hooks to change your brand logo, unless you want to version control it, otherwise you can use Website Settings to change it.\n\nBase Template\n\nWhen a web page is rendered, it extends templates/base.html by default. You can override the base template by overriding the base_template hook.\n\napp/hooks.py\n\nbase_template = \"app/templates/my_custom_base.html\"\n\nYou can also customize base templates based on routes. For e.g., if you want to use a different base template for all the routes that start with docs/* then you can use the base_template_map hook. The key must be a regex that matches the route. All other routes will fallback to the default base template.\n\napp/hooks.py\n\nbase_template_map = {\n r\"docs.*\": \"app/templates/doc_template.html\"\n}\n\nIntegrations\n\nThese hooks allow you to customize behaviour of 3rd-party integrations in Frappe.\n\nBraintree Success Page\n\nThis hook allows you to override the default redirect URL on successful payment of Braintree transaction.\n\napp/hooks.py\n\nbraintree_success_page = \"app.integrations.braintree_success_page\"\n\nThe method is called with one argument data which has the meta data of the payment.\n\napp/integrations.py\n\ndef braintree_success_page(data):\n # data.reference_doctype\n # data.reference_docname\n return \"/thank-you\"\n\nCalendars\n\nThe calendar hook is a list of doctype names which are shown as menu items for quick navigation from the Calendar page in Desk.\n\napp/hooks.py\n\ncalendars = [\"Appointment\"]\n\n \n\nClear Cache\n\nThis hook allows you to clear your app specific cache values when the global cache is being cleared by frappe.\n\napp/hooks.py\n\nclear_cache = \"app.cache.clear_cache\"\n\nYou can use this hook to clear your app specific cache. The method is called without any arguments.\n\napp/cache.py\n\ndef clear_cache():\n frappe.cache().hdel(\"app_specific_cache\")\n\nDefault Mail Footer\n\nIf you want to set the default footer of all the emails that are sent out by Frappe, you can use the default_mail_footer hook.\n\napp/hooks.py\n\ndefault_mail_footer = \"\"\"\n <div>\n Sent via <a href=\"https://tennismart.com\" target=\"_blank\">TennisMart</a>\n</div>\n\"\"\"\n\nNow, all the emails will have Sent via TennisMart in the footer.\n\nSession Hooks\n\nThese hooks are triggered over the login lifecycle of a user. on_login is triggered immediately after a successful login, on_session_creation is triggered after the session is setup, on_logout is triggered after the user logs out.\n\napp/hooks.py\n\non_login = \"app.overrides.successful_login\"\non_session_creation = \"app.overrides.allocate_free_credits\"\non_logout = \"app.overrides.clear_user_cache\"\n\nThe method will be called with one argument login_manager.\n\napp/overrides.py\n\ndef allocate_free_credits(login_manager):\n # allocate free credits to frappe.session.user\n pass\n\nAuth Hooks\n\nThese hooks are triggered during request authentication. Custom headers, Authorization headers can be validated here, user is verified and mapped to the request using frappe.set_user(). Use frappe.request and frappe.* to validate request and map user.\n\napp/hooks.py\n\nauth_hooks = [\"app.overrides.validate_custom_jwt\"]\n\nThe method will be called during request authentication.\n\napp/overrides.py\n\ndef validate_custom_jwt():\n # validate jwt from header, verify signature, set user from jwt.\n pass\n\nUse this method to check for incoming request header, verify the header and map the user to the request. If header verification fails DO NOT throw error to continue with other hooks. Unverified request is treated as \"Guest\" request by default. You may use third party server, shared database or any alternative of choice to verify and map request and user.\n\nFixtures\n\nFixtures are database records that are synced using JSON files when you install and update your site.\n\nLet's say you want to create a set of categories in the database whenever you install your app. To do that, create the set of categories in your local site, and add the doctype name in the fixtures hook.\n\nfixtures = [\n # export all records from the Category table\n \"Category\"\n]\n\nNow, run the following command:\n\nbench --site sitename export-fixtures\n\nThis command will create a JSON file for each doctype which will contain the data to generate list of records. You can test this by creating a new site and by installing your app on that site.\n\nYou can also add conditions for exporting records.\n\nfixtures = [\n # export all records from the Category table\n \"Category\",\n # export only those records that match the filters from the Role table\n {\"dt\": \"Role\", \"filters\": [[\"role_name\", \"like\", \"Admin%\"]]},\n]\n\nSome fields are for internal use only. They will be set and kept up-to-date by the system automatically. These will not get exported: modified_by, creation, owner, idx, lft and rgt. For child table records, the following fields will not get exported: docstatus, doctype, modified and name.\n\nDocument Hooks\n\nModify List Query\n\nYou can customize how list of records are queried for a DocType by adding custom match conditions using the permission_query_conditions hook. This match condition must be a valid WHERE clause fragment for an SQL query.\n\napp/hooks.py\n\npermission_query_conditions = {\n \"ToDo\": \"app.permissions.todo_query\",\n}\n\nThe method is called with a single argument user which can be None. The method should return a string that is a valid SQL WHERE clause.\n\napp/permissions.py\n\ndef todo_query(user):\n if not user:\n user = frappe.session.user\n # todos that belong to user or assigned by user\n return \"(`tabToDo`.owner = {user} or `tabToDo`.assigned_by = {user})\".format(user=frappe.db.escape(user))\n\nNow, if you use the frappe.db.get_list method, your WHERE clause will be appended to the query.\n\ntodos = frappe.db.get_list(\"ToDo\", debug=1)\n\n# output\n'''\nselect `tabToDo`.`name`\nfrom `tabToDo`\nwhere ((`tabToDo`.owner = 'john@doe.com' or `tabToDo`.assigned_by = 'john@doe.com'))\norder by `tabToDo`.`modified` DESC\n'''\n\n This hook will only affect the result of frappe.db.get_list method and not > frappe.db.get_all.\n\nDocument Permissions\n\nYou can modify the behaviour of doc.has_permission document method for any DocType and add custom permission checking logic using the has_permission hook.\n\napp/hooks.py\n\nhas_permission = {\n \"Event\": \"app.permissions.event_has_permission\",\n}\n\nThe method will be passed the doc, user and permission_type as arguments. It should return True or a False value. If None is returned, it will fallback to default behaviour.\n\napp/permissions.py\n\ndef event_has_permission(doc, user=None, permission_type=None):\n # when reading a document allow if event is Public\n if permission_type == \"read\" and doc.event_type == \"Public\":\n return True\n\n # when writing a document allow if event owned by user\n if permission_type == \"write\" and doc.owner == user:\n return True\n\n return False\n\nExtend DocType Class\n\n Note: this is available in v16+\n\nYou can extend the class for standard doctypes by using the extend_doctype_class hook. This hook allows you to add properties, methods, and functionality to existing DocType classes without overriding them completely, enabling multiple apps to extend the same DocType class.\n\napp/hooks.py\n\nextend_doctype_class = {\n \"Address\": [\"app.extensions.address.AddressMixin\"]\n}\n\napp/extensions/address.py\n\nfrom frappe.model.document import Document\n\nclass AddressMixin(Document):\n @property\n def full_address(self):\n return f\"{self.address_line1}, {self.city}, {self.country}\"\n\n def custom_validation(self):\n # Custom validation logic\n pass\n\n def validate(self):\n super.validate()\n self.custom_validation()\n\nMultiple Extensions\n\nYou can define multiple extensions for the same DocType. For example, the ValidationMixin could be used in Contact as well as in Address, while the GeocodingMixin is used only in Address.\n\napp/hooks.py\n\nextend_doctype_class = {\n \"Address\": [\n \"app.extensions.address.GeocodingMixin\",\n \"app.extensions.common.ValidationMixin\"\n ],\n \"Contact\": [\n \"app.extensions.common.ValidationMixin\"\n ]\n}\n\nHooks Resolution Order\n\nWhen multiple apps define extensions for the same DocType, the extensions are applied in the hooks resolution order. If apps are resolved in the order frappe, app1, app2, the final class will be:\n\nclass ExtendedAddress(App2Mixin, App1Mixin, Address):\n pass\n\nInteraction with override_doctype_class\n\nThe extend_doctype_class hook works on top of override_doctype_class. If both hooks are defined, extensions are applied to the overridden class instead of the base class.\n\nFor example, if ERPNext overrides the Address class and custom apps extend it:\n\n# ERPNext overrides Address\noverride_doctype_class = {\n \"Address\": \"erpnext.setup.doctype.address.address.Address\"\n}\n\n# Custom apps extend it\nextend_doctype_class = {\n \"Address\": [\"app1.extensions.Prop1Mixin\", \"app2.extensions.Prop2Mixin\"]\n}\n\n# Final class becomes:\nclass ExtendedAddress(Prop2Mixin, Prop1Mixin, ERPNextAddress):\n pass\n\nThis hook is ideal for adding virtual fields, computed properties, and custom methods without disrupting the core functionality. It's recommended to use this hook instead of override_doctype_class when you only need to add functionality rather than replace it.\n\nOverride DocType Class\n\nYou can override/extend the class for standard doctypes by using the override_doctype_class hook. Unlike extend_doctype_class, this hook completely replaces the original class. This can cause issues when you have multiple apps overriding the same DocType class. In v16+, prefer using extend_doctype_class instead.\n\napp/hooks.py\n\noverride_doctype_class = {\n \"ToDo\": \"app.overrides.todo.CustomToDo\"\n}\n\napp/overrides/todo.py\n\nfrom frappe.desk.doctype.todo.todo import ToDo\n\nclass CustomToDo(ToDo):\n def on_update(self):\n self.my_custom_code()\n super().on_update()\n\n def my_custom_code(self):\n pass\n\n It is recommended that you extend the standard class of the doctype, otherwise you will have to implement all of the core functionality.\n\nOverride Form Scripts\n\nYou can override/extend Standard Form Scripts by using the doctype_js hook.\n\napp/hooks.py\n\ndoctype_js = {\n \"ToDo\": \"public/js/todo.js\",\n}\n\napp/public/js/todo.js\n\nfrappe.ui.form.on(\"Todo\", {\n refresh: function(frm) {\n frm.trigger(\"my_custom_code\");\n },\n my_custom_code: function(frm){\n console.log(frm.doc.name)\n }\n});\n\n The events/functions defined in app/public/todo.js will extend > those in the standard form script of ToDo doctype.\n\nCRUD Events\n\nYou can hook into various CRUD events of any doctype using the doc_events hook.\n\napp/hooks.py\n\ndoc_events = {\n \"*\": {\n # will run after any DocType record is inserted into database\n \"after_insert\": \"app.crud_events.after_insert_all\"\n },\n \"ToDo\": {\n # will run before a ToDo record is inserted into database\n \"before_insert\": \"app.crud_events.before_insert_todo\",\n }\n}\n\nThe method will be passed the doc and the method name as arguments.\n\napp/crud_events.py\n\ndef after_insert_all(doc, method=None):\n pass\n\ndef before_insert_todo(doc, method=None):\n pass\n\n See Controller Hooks > for a list of all available hooks.\n\nOverride Whitelisted Methods\n\nWhitelisted Methods are python methods that are accessible on a REST endpoint and consumed by a client. You can override standard whitelisted methods that are part of the core framework using the override_whitelisted_methods hook.\n\napp/hooks.py\n\noverride_whitelisted_methods = {\n \"frappe.client.get_count\": \"app.whitelisted.custom_get_count\"\n}\n\nThe method should have the same signature as the original method.\n\napp/whitelisted.py\n\ndef custom_get_count(doctype, filters=None, debug=False, cache=False):\n # your custom implementation of the standard get_count method provided by frappe\n pass\n\nIgnore Links on Delete\n\nTo ignore links to specific DocTypes when deleting documents, you can specify them in the ignore_links_on_delete hook like so:\n\napp/hooks.py\n\nignore_links_on_delete = [\"Communication\", \"ToDo\"]\n\nForm Timeline\n\nThe timeline section of form view of a document shows an audit trail of actions performed on that document like views, value changes, comments and related communications, etc.\n\nApart from these standard actions, there might arise a situation where you need to add your own custom actions. You can do this via additional_timeline_content hook.\n\nadditional_timeline_content: {\n # show in each document's timeline\n \"*\": [\"app.timeline.all_timeline\"]\n # only show in ToDo's timeline\n \"ToDo\": [\"app.timeline.todo_timeline\"]\n}\n\nThe method will be passed the doctype and docname as arguments. You can perform queries and return actions related to that document as a list of dicts as shown in the example. Each dict in the list must have a creation value which will be used to sort the item in the timeline.\n\ndef todo_timeline(doctype, docname):\n # this method should return a list of dicts\n return [\n {\n # this will be used to sort the content in the timeline\n \"creation\": \"22-05-2020 18:00:00\",\n # this JS template will be rendered in the timeline\n \"template\": \"custom_timeline_template\",\n # this data will be passed to the template.\n \"template_data\": {\"key\": \"value\"},\n },\n ...\n ]\n\nScheduler Events\n\nYou can use Scheduler Events for running tasks periodically in the background using the scheduler_events hook.\n\napp/hooks.py\n\nscheduler_events = {\n \"hourly\": [\n # will run hourly\n \"app.scheduled_tasks.update_database_usage\"\n ],\n}\n\napp/scheduled_tasks.py\n\ndef update_database_usage():\n pass\n\n After changing any scheduled events in hooks.py, you need to run bench migrate for changes to take effect.\n\nAvailable Events\n\nhourly, daily, weekly, monthly\n\nThese events will trigger every hour, day, week and month respectively.\n* hourly_long, daily_long, weekly_long, monthly_long\n\nSame as above but these jobs are run in the long worker suitable for long running jobs.\n* all\n\nThe all event is triggered every 60 seconds. This can be configured via the scheduler_tick_interval key in common_site_config.json\n* cron\n\nA valid cron string that can be parsed by croniter.\n\nUsage Examples:\n\nscheduler_events = {\n \"daily\": [\n \"app.scheduled_tasks.manage_recurring_invoices\"\n ],\n \"daily_long\": [\n \"app.scheduled_tasks..take_backups_daily\"\n ],\n \"cron\": {\n \"15 18 * * *\": [\n \"app.scheduled_tasks..delete_all_barcodes_for_users\"\n ],\n \"*/6 * * * *\": [\n \"app.scheduled_tasks..collect_error_snapshots\"\n ],\n \"annual\": [\n \"app.scheduled_tasks.collect_error_snapshots\"\n ]\n }\n}\n\nJinja Customization\n\nFrappe provides a list of global utility methods in Jinja templates. To add your own methods and filters you can use the jinja hook.\n\napp/hooks.py\n\njinja = {\n \"methods\": [\n \"app.jinja.methods\",\n \"app.utils.get_fullname\"\n ],\n \"filters\": [\n \"app.jinja.filters\",\n \"app.utils.format_currency\"\n ]\n}\n\napp/jinja/methods.py\n\ndef sum(a, b):\n return a + b\n\ndef multiply(a, b):\n return a * b\n\n If the path is a module path, all the methods in that module will be added.\n\napp/utils.py\n\ndef get_fullname(user):\n first_name, last_name = frappe.db.get_value(\"User\", user, [\"first_name\", \"last_name\"])\n return first_name + \" \" + last_name\n\ndef format_currency(value, currency):\n return currency + \" \" + str(value)\n\nNow, you can use these utilities in your Jinja templates like so:\n\n<h1>Hi, {{ get_fullname(frappe.session.user) }}</h1>\n<p>Your account balance is {{ account_balance | format_currency(\"INR\") }}</p>\n<p>1 + 2 = {{ sum(1, 2) }}</p>\n\nPrevent Auto Cancellation of Linked Documents\n\nTo prevent documents of a specific DocType from being automatically cancelled on the cancellation of any linked documents you can use the auto_cancel_exempted_doctypes hook.\n\napp/hooks.py\n\nauto_cancel_exempted_doctypes = [\"Payment Entry\"]\n\nIn the above example, if any document (for e.g Sales Invoice) that is linked with Payment Entry is cancelled, it will skip the auto-cancellation of the linked Payment Entry document.\n\nNotification configurations\n\nThe notification configuration hook is used to customize the items shown in the Notification dropdown in Desk. It can be configured by the notification_config hook.\n\napp/hooks.py\n\nnotification_config = \"app.notification.get_config\"\n\nThe method is called without any arguments.\n\napp/notification.py\n\ndef get_config():\n return {\n \"for_doctype\": {\n \"Issue\": {\"status\":\"Open\"},\n \"Issue\": {\"status\":\"Open\"},\n },\n \"for_module_doctypes\": {\n \"ToDo\": \"To Do\",\n \"Event\": \"Calendar\",\n \"Comment\": \"Messages\"\n },\n \"for_module\": {\n \"To Do\": \"frappe.core.notifications.get_things_todo\",\n \"Calendar\": \"frappe.core.notifications.get_todays_events\",\n \"Messages\": \"frappe.core.notifications.get_unread_messages\"\n }\n }\n\nThe above configuration has three parts:\n\nfor_doctype part of the above configuration marks any \"Issue\" or \"Customer Issue\" as unread if its status is Open\nfor_module_doctypes maps doctypes to module's unread count.\nfor_module maps modules to functions to obtain its unread count. The functions are called without any argument.\n\nRequired Apps\n\nWhen building apps, you might create apps that build on top of other apps. To make sure dependent apps are installed when someone installs your app, you can use the required_apps hook.\n\napp/hooks.py\n\nrequired_apps = [\"erpnext\"]\n\nThe above configuration will make sure erpnext is installed when someone installs your app.\n\nUser Data Protection & Privacy\n\nUser Data Privacy features like personal data download and personal data deletion come out of the box in Frappe. What constitutes as personal data may be defined by the App publisher in the application's hooks.py file as user_data_fields.\n\napp/hooks.py\n\nuser_data_fields = [\n {\"doctype\": \"Access Log\"},\n {\"doctype\": \"Comment\", \"strict\": True},\n {\n \"doctype\": \"Contact\",\n \"filter_by\": \"email_id\",\n \"rename\": True,\n },\n {\"doctype\": \"Contact Email\", \"filter_by\": \"email_id\"},\n {\n \"doctype\": \"File\",\n \"filter_by\": \"attached_to_name\",\n \"redact_fields\": [\"file_name\", \"file_url\"],\n },\n {\"doctype\": \"Email Unsubscribe\", \"filter_by\": \"email\", \"partial\": True},\n]\n\nDocTypes that have user data should be mapped under this hook using the above format. Upon data deletion or download requests from users, this hook will be utilized to map over the specified DocTypes. The options available to modify documents are:\n\n Field\n Description\n\n doctype\n DocType that contains user data.\n\n filter_by\n Docfield to filter the documents by. If unset, defaults to owner.\n\n partial\n If set, all text fields are parsed and user's full name and username references will be redacted.\n\n redact_fields\n Fields that have to be redacted. If unspecified, it considers partial data redaction from all text fields.\n\n rename\n If document name contains user data, set this field to rename document to anonymize it.\n\n strict\n If set to True, any user data will be redacted from all documents of current DocType. If unset, it defaults to False which means it only filters through documents in which user is the owner.\n\n Note: Personal Data Download only utilizes the doctype and filter_by fields defined in user_data_fields\n\nRelated Topics:\n\nPersonal Data Deletion\nPersonal Data Download\n\nSignup Form Template\n\nIf you want to add additional fields to the signup form you can use this hook. Create a template file which contains the custom signup form. Pass this template to the custom signup hook.\n\nsignup_form_template = \"school/templates/signup-form.html\"\n\n Note: If you want custom fields in signup form, it will require additional fields in the user doctype. You will have to add these fields using fixtures. Also you will have to write your own submit handler for this signup form and a function on the server side which will signup the user. This way you can also write validations for the custom fields you add.\n\nSMS Hooks\n\nThese hooks allow you to customize the SMS sending functionality in Frappe by integrating with third-party SMS providers or implementing custom SMS logic.\n\nSend SMS\n\nThis hook allows you to override the default SMS sending logic for notifications, bulk SMS, and other general SMS functionality.\n\napp/hooks.py\n\nsend_sms = \"app.overrides.sms.send_sms\"\n\nThe method is called with the SMS details including recipient, message content, and other metadata.\n\napp/overrides/sms.py\n\ndef send_sms(receiver_list, msg, sender=None, success_msg=True):\n \"\"\"\n Override default SMS sending logic\n\n Args:\n receiver_list: List of mobile numbers or single mobile number\n msg: SMS message content\n sender: Sender ID (optional)\n success_msg: Whether to show success message (optional)\n \"\"\"\n\n # Send SMS via custom provider\n response = custom_sms_provider.send_sms(\n to=receiver_list,\n message=msg,\n from_number=sender\n )\n\n if response.status_code == 200:\n frappe.msgprint(_(\"SMS sent successfully\"))\n return True\n else:\n frappe.throw(_(\"Failed to send SMS\"))\n return False\n\nSend Token via SMS\n\nThis hook allows you to override SMS OTP sending logic for two-factor authentication and mobile login flows.\n\napp/hooks.py\n\nsend_token_via_sms = \"app.overrides.sms.send_token_via_sms\"\n\nThe method is called with OTP details for authentication purposes.\n\napp/overrides/sms.py\n\ndef send_token_via_sms(otpsecret, token=None, phone_no=None):\n \"\"\"\n Generate OTP and send using local send_otp function.\n :param otpsecret: OTP secret for generating HOTP\n :param token: Token to use for HOTP generation\n :param phone_no: Phone number to send OTP to\n \"\"\"\n if not phone_no:\n return False\n try:\n hotp = pyotp.HOTP(otpsecret)\n otp_code = hotp.at(token_int)\n result = send_otp(\n number=phone_no,\n otp_length=len(otp_code),\n otp_expiry=5, # 5 minutes expiry\n otp=otp_code\n )\n return result.get(\"success\", False)\n except Exception as e:\n frappe.log_error(\n message=f\"Failed to send OTP: {str(e)}\",\n title=\"OTP Error\"\n )\n return False \n\nList of available hooks\n\n Hook Name\n Explanation\n\n additional_timeline_content\n Form Timeline\n\n after_install\n Install Hooks\n\n after_migrate\n Migrate Hooks\n\n after_sync\n Install Hooks\n\n app_include_css\n Desk Assets\n\n app_include_js\n Desk Assets\n\n app_logo_url\n App Meta Data\n\n app_title\n App Meta Data\n\n auto_cancel_exempted_doctypes\n Prevent Auto Cancellation\n\n base_template_map\n Base Template\n\n base_template\n Base Template\n\n before_install\n Install Hooks\n\n before_migrate\n Migrate Hooks\n\n before_tests\n Test Hooks\n\n before_write_file\n File Hooks\n\n bot_parsers\n Deprecated\n\n braintree_success_page\n Braintree Success Page\n\n brand_html\n Brand HTML\n\n calendars\n Calendars\n\n clear_cache\n Clear Cache\n\n communication_doctypes\n \n\n default_mail_footer\n Default Mail Footer\n\n delete_file_data_content\n File Hooks\n\n doc_events\n Document CRUD Events\n\n doctype_js\n Override Form Scripts\n\n domains\n \n\n dump_report_map\n Deprecated\n\n extend_bootinfo\n Extend Bootinfo\n\n extend_website_page_controller_context\n Website Controller Context\n\n filters_config\n \n\n fixtures\n Fixtures\n\n get_site_info\n \n\n get_translated_dict\n \n\n get_website_user_home_page\n Default Homepage\n\n get_web_pages_with_dynamic_routes\n Web pages with dynamic routes\n\n has_permission\n Document Permissions\n\n has_website_permission\n \n\n home_page\n Default Homepage\n\n jenv\n Jinja Customization\n\n leaderboards\n \n\n look_for_sidebar_json\n \n\n make_email_body_message\n \n\n notification_config\n Notification configuration\n\n on_login\n Session Hooks\n\n on_logout\n Session Hooks\n\n on_print_pdf\n On printing\n\n on_session_creation\n Session Hooks\n\n extend_doctype_class\n Extend DocType Class\n\n override_doctype_class\n Override DocType Class\n\n override_doctype_dashboards\n \n\n override_whitelisted_methods\n Override Whitelisted Methods\n\n ignore_links_on_delete\n Ignore Links on Delete\n\n permission_query_conditions\n Modify List Query\n\n portal_menu_items\n Portal Sidebar\n\n required_apps\n Required Apps\n\n role_home_page\n Default Homepage\n\n scheduler_events\n Scheduler Events\n\n setup_wizard_complete\n \n\n setup_wizard_exception\n \n\n setup_wizard_requires\n \n\n setup_wizard_stages\n \n\n setup_wizard_success\n \n\n signup_form_template\n Signup Form Template\n\n sounds\n Sounds\n\n standard_portal_menu_items\n Portal Sidebar\n\n standard_queries\n \n\n send_sms\n SMS Hooks\n\n send_token_via_sms\n SMS Hooks\n\n template_apps\n \n\n translated_languages_for_website\n \n\n translator_url\n \n\n treeviews\n DocTypes that use TreeView as the default view (instead of ListView)\n\n update_website_context\n Website Context\n\n user_privacy_documents\n Deprecated (Use user_data_fields hook)\n\n user_data_fields\n User Data Protection & Privacy\n\n web_include_css\n Portal Assets\n\n web_include_js\n Portal Assets\n\n website_catch_all\n Website 404\n\n website_clear_cache\n Website Clear Cache\n\n website_context\n Website Context\n\n website_generators\n Deprecated (Use Has Web View in DocType instead)\n\n website_redirects\n Website Redirects\n\n website_route_rules\n Website Route Rules\n\n website_user_home_page\n Deprecated (Use homepage hook)\n\n welcome_email\n \n\n write_file_keys\n Deprecated\n\n write_file\n File Hooks",
  "scrapedAt": "2025-10-22T00:01:49.612Z"
}