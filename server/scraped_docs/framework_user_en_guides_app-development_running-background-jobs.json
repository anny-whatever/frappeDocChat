{
  "route": "framework/user/en/guides/app-development/running-background-jobs",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/guides/app-development/running-background-jobs",
  "title": "running-background-jobs",
  "content": "Sometimes you may not want a user request to be executed immediately but added to a queue that will be executed by a background worker. The advantage of doing this is that your web workers remain free to execute other requests and longer jobs do not eat up all of your resources.\n\nFrappe uses Python RQ to run background jobs. The following example illustrates how you can enqueue a job:\n\nimport frappe\n\ndef long_job(arg1, arg2):\n frappe.publish_realtime('msgprint', 'Starting long job...')\n # this job takes a long time to process\n frappe.publish_realtime('msgprint', 'Ending long job...')\n\ndef enqueue_long_job(arg1, args2):\n frappe.enqueue('myapp.mymodule.long_job', arg1=arg1, arg2=arg2)\n\nThis will enqueue long_job to the queue default. Other available queues are long and short. You should choose the appropriate queue based on how long you estimate your enqueued job to execute.\n\nStarting Version 14, you can also enqueue jobs at front of the queue by passing at_front as True in your enqueue call.\n\nCalled delayed actions on Document objects\n\nYou can also called delayed actions on document objects, for example in Stock Reconciliation if there are more than 100 items, it is executed as a background job.\n\nExample: you can call doc.queue_action('submit')\n\nNote: This only works for save, submit, cancel\n\nYou can also push certain actions to the background if you anticipate the execution is very large.\n\nFor example:\n\ndef submit(self):\n if len(self.items) > 100:\n self.queue_action('submit')\n else:\n self._submit()\n\nDebugging\n\nIf you are on bench start\n\nYou will see logs in your terminal.\n\nNote: default worker does not auto restart, so you will have to kill bench and start again after you make changes.",
  "scrapedAt": "2025-10-22T00:02:30.072Z"
}