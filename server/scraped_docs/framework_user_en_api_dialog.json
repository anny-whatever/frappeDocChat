{
  "route": "framework/user/en/api/dialog",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/api/dialog",
  "title": "dialog",
  "content": "Frappe provides a group of standard, interactive and flexible dialogs that are easy to configure and use. There's also an API for Python.\n\nfrappe.ui.Dialog\n\nnew frappe.ui.Dialog({ title, fields, primary_action })\n\nCreates a new Dialog instance.\n\nlet d = new frappe.ui.Dialog({\n title: 'Enter details',\n fields: [\n {\n label: 'First Name',\n fieldname: 'first_name',\n fieldtype: 'Data'\n },\n {\n label: 'Last Name',\n fieldname: 'last_name',\n fieldtype: 'Data'\n },\n {\n label: 'Age',\n fieldname: 'age',\n fieldtype: 'Int'\n }\n ],\n size: 'small', // small, large, extra-large \n primary_action_label: 'Submit',\n primary_action(values) {\n console.log(values);\n d.hide();\n }\n});\n\nd.show();\n\n frappe.ui.Dialog\n\nfrappe.msgprint\n\nfrappe.msgprint(message) or frappe.msgprint({ title, message, indicator })\n\nShow message in a modal.\n\n// only message\nfrappe.msgprint(__('Document updated successfully'));\n\n// with options\nfrappe.msgprint({\n title: __('Notification'),\n indicator: 'green',\n message: __('Document updated successfully')\n});\n\n frappe.msgprint\n\nYou can also bind a primary action to this dialog by passing action(as a method) within primary_action. Alternatively, primary_action can contain server_action or client_action.\n\nThe server_action and client_action are dotted paths to the respective methods which will execute on clicking the primary button.\n\n// with primary action\n frappe.msgprint({\n title: __('Notification'),\n message: __('Are you sure you want to proceed?'),\n primary_action:{\n action(values) {\n console.log(values);\n }\n }\n});\n\n// with server and client action\nfrappe.msgprint({\n title: __('Notification'),\n message: __('Are you sure you want to proceed?'),\n primary_action: {\n 'label': 'Proceed',\n // either one of the actions can be passed\n 'server_action': 'dotted.path.to.method',\n 'client_action': 'dotted_path.to_method',\n 'args': args\n }\n});\n\n frappe.msgprint with primary action bound\n\nfrappe.throw\n\nfrappe.throw(error_message)\n\nShow error_message in a modal and throw exception.\n\nfrappe.throw(__('This is an Error Message'))\n\n frappe.throw\n\nfrappe.prompt\n\nfrappe.prompt(label) or frappe.prompt(df) or frappe.prompt(fields)\n\nPrompt user for a value or list of values.\n\n// prompt for single value of type Data\nfrappe.prompt('First Name', ({ value }) => console.log(value))\n\n// Set title and button label\nfrappe.prompt('First Name', console.log, 'Enter First Name', 'Submit');\n\n// prompt for single value of any type\nfrappe.prompt({\n label: 'Birth Date',\n fieldname: 'date',\n fieldtype: 'Date'\n}, (values) => {\n console.log(values.date);\n})\n\n// prompt for multiple values\nfrappe.prompt([\n {\n label: 'First Name',\n fieldname: 'first_name',\n fieldtype: 'Data'\n },\n {\n label: 'Last Name',\n fieldname: 'last_name',\n fieldtype: 'Data'\n },\n], (values) => {\n console.log(values.first_name, values.last_name);\n})\n\n frappe.prompt\n\nfrappe.confirm\n\nfrappe.confirm(message, if_yes, if_no)\n\nShow a confirmation modal, executes if_yes if confirmation is given else executes if_no.\n\nfrappe.confirm('Are you sure you want to proceed?',\n () => {\n // action to perform if Yes is selected\n }, () => {\n // action to perform if No is selected\n })\n\n frappe.confirm\n\nfrappe.warn\n\nfrappe.warn(title, message_html, proceed_action, primary_label, is_minimizable)\n\nShow a warning modal, executes proceed_actiion if confirmation is given. It can be set as minimizable which allows the dialog to be minimized.\n\nfrappe.warn('Are you sure you want to proceed?',\n 'There are unsaved changes on this page',\n () => {\n // action to perform if Continue is selected\n },\n 'Continue',\n true // Sets dialog as minimizable\n)\n\n frappe.confirm\n\nfrappe.show_alert\n\nfrappe.show_alert(message, seconds) or frappe.show_alert({message, indicator}, seconds)\n\nAlert Dialog is used for showing non-obstructive messages.\n\nIts parameters include message, which can contain the indicator color as well, and its display duration. The default is 7 seconds.\n\nfrappe.show_alert('Hi, you have a new message', 5);\n\n//show_alert with indicator\nfrappe.show_alert({\n message:__('Hi, you have a new message'),\n indicator:'green'\n}, 5);\n\n frappe.show_alert\n\nfrappe.show_progress\n\nfrappe.show_progress(title, count, total, description)\n\nDisplays a progress bar with count (as current progress) and total (as maximum progress value).\n\nfrappe.show_progress('Loading..', 70, 100, 'Please wait');\n\n frappe.show_progress\n\nfrappe.new_doc\n\nfrappe.new_doc(doctype, route_options, init_callback)\n\nOpens a new form of the specified DocType that allows to edit and save it. If \"Quick Entry\" is enabled for the DocType (that allows to enter the most important fields) the \"Quick Entry\" pop-up window will be shown. Otherwise you will be redirected to the usual document entry form.\n\nFor example, let's create a new Task:\n\nfrappe.new_doc(\"Task\");\n\nOften when you are creating a new document in the user interface you want to initialize some of its fields based on the user interaction that triggered the creation. The other two arguments can be used for such initialization.\n\nSpecifically, the route_options argument is a quick and convenient way to set any field of type Link, Select, Data, or Dynamic Link in the new document. Its value should be an object whose keys are the desired field names and whose values are the initial values.\n\nfrappe.new_doc(\"Task\", {subject: \"New Task\"});\n\nIf you need to do any other initialization of the new document that is not possible with route_options, init_callback gives you full control. It should be a function of one argument. If the doctype is initialized with a \"Quick Entry\" form, the callback is called with the \"Quick Entry\" dialog object just before control is released back to the user. Otherwise, the callback is called with the new document just before the user is allowed to edit it in the standard form.\n\nfrappe.new_doc(\"Task\", {subject: \"New Task\"},\n doc => {doc.description = \"Do what's necessary\";});\n\nNote that subject is a field of type \"Data\", so we are able to take advantage of the route_options argument to set it. description is a field of type \"Text Editor\", so if we want to initialize it, that must be done in the callback.\n\nFor a slightly more complex example, here's a call that creates a new Journal Entry of type \"Bank Entry\" and populates one side of the transaction:\n\nfrappe.new_doc(\"Journal Entry\", {\"voucher_type\": \"Bank Entry\"}, doc => {\n doc.posting_date = frappe.datetime.get_today();\n let row = frappe.model.add_child(doc, \"accounts\");\n row.account = 'Bank - A';\n row.account_currency = 'USD';\n row.debit_in_account_currency = 100.0;\n row.credit_in_account_currency = 0.0;\n});\n\nfrappe.ui.form.MultiSelectDialog\n\nnew frappe.ui.form.MultiSelectDialog({ doctype, target, setters, date_field, get_query, action })\n\nA MultiSelectDialog consists of filter fields followed by a multiple selection list. The primary button will perform the passed action on the selected options.\n\nBy default, the Search Term field and Date Range field will compose the filter fields.\n\nThe argument list includes:\n\ndoctype: The source to fetch and display selection entries from.\ntarget: The target where the modal is to be displayed.\nsetters: These will compose the filter fields and values to populate them with. These also translate to custom columns for the selection list.\nread_only_setters: If you want to make setters (filters) read only so that users can't change the value of the filters then add those fields in the \"readonlysetters\".\nadd_filters_group: A boolean value to add/remove the filter group in the dialog below setters. The filter group is same as the list view filters.\ndate_field: It is necessary to pass the date_field of the DocType in consideration.\nget_query: A function that returns query and filters to query the selection list. A custom server side method can be passed via query, and filters will be passed to that method.\naction: Contains the primary action to be performed on the selected options. It takes selections as a parameter, which comprises of the selected options.\ncolumns: An array of fields returned by custom query which will become columns in result datatable. Only works with the custom query (get_query argument returning a query).\n\nLet us assume we want to fetch Material Requests into our dialog. We can then go on to invoke the MultiSelectDialog in the following manner:\n\nnew frappe.ui.form.MultiSelectDialog({\n doctype: \"Material Request\",\n target: this.cur_frm,\n setters: {\n schedule_date: null,\n status: 'Pending'\n },\n add_filters_group: 1,\n date_field: \"transaction_date\",\n get_query() {\n return {\n filters: { docstatus: ['!=', 2] }\n }\n },\n action(selections) {\n console.log(selections);\n }\n});\n\n// MultiSelectDialog with custom query method\nlet query_args = {\n query:\"dotted.path.to.method\",\n filters: { docstatus: [\"!=\", 2], supplier: \"John Doe\" }\n}\n\nnew frappe.ui.form.MultiSelectDialog({\n doctype: \"Material Request\",\n target: this.cur_frm,\n setters: {\n schedule_date: null,\n status: 'Pending'\n },\n add_filters_group: 1,\n date_field: \"transaction_date\",\n columns: [\"name\", \"transaction_date\", \"status\"],\n get_query() {\n return query_args;\n },\n action(selections) {\n console.log(selections);\n }\n});\n\n frappe.ui.form.MultiSelectDialog\n\nHere all the Material Requests that fulfill the filter criteria will be fetched into the selection area. The setter company is added to the filter fields along with its passed value. The date_field will be used to fetch and query dates from the DocType mentioned.\n\nThe Make Material Request (or Make {DocType}) secondary action button will redirect you to a new form in order to make a new entry into the DocType passed.\n\nNow, if we want to only select particular item from a Material Request, then we can use optional child_selection_mode to enable child selection\n\n// MultiSelectDialog for individual child selection\nnew frappe.ui.form.MultiSelectDialog({\n doctype: \"Material Request\",\n target: this.cur_frm,\n setters: {\n schedule_date: null,\n status: null\n },\n add_filters_group: 1,\n date_field: \"transaction_date\",\n allow_child_item_selection: 1,\n child_fieldname: \"items\", // child table fieldname, whose records will be shown &amp; can be filtered\n child_columns: [\"item_code\", \"qty\"], // child item columns to be displayed\n get_query() {\n return {\n filters: { docstatus: ['!=', 2] }\n }\n },\n action(selections, args) {\n console.log(args.filtered_children); // list of selected item names\n }\n});\n\n frappe.ui.form.MultiSelectDialog\n\nHere you will see a checkbox Select Individual Items to toggle between child item selection & parent selection. Once you toggle it, all the individual Material Requests Items are listed from the all the queried Material Request, you can now filter these items for selection.\n\nTo access the selected children, you can use args.filtered_children list which contains selected child item names.\n\nTable / Grid in a Dialog\n\nA table can be added to a dialog, just like any other field as follows:\n\nconst dialog = new frappe.ui.Dialog({\n title: __(\"Create Logs\"),\n fields: [\n {\n fieldname: \"logs\",\n fieldtype: \"Table\",\n label: __(\"Logs\"),\n in_place_edit: true,\n reqd: 1,\n fields: [\n {\n fieldname: \"log_type\",\n label: __(\"Log Type\"),\n fieldtype: \"Select\",\n options: \"\nIN\nOUT\",\n in_list_view: 1,\n reqd: 1,\n },\n {\n fieldname: \"time\",\n label: __(\"Time\"),\n fieldtype: \"Time\",\n in_list_view: 1,\n reqd: 1,\n }\n ],\n on_add_row: (idx) => {\n // idx = visible idx of the row starting from 1\n // eg. set `log_type` as alternating IN/OUT in the table on row addition\n let data_id = idx - 1;\n let logs = dialog.fields_dict.logs;\n let log_type = (data_id % 2) == 0 ? \"IN\" : \"OUT\";\n\n logs.df.data[data_id].log_type = log_type;\n logs.grid.refresh();\n },\n },\n ],\n primary_action: (values) => { ... },\n primary_action_label: __(\"Create\"),\n});\n\non_add_row: An event that gets triggered on adding a row to the table. You can perform an action like data manipulation or some other sort of calculation by adding your functionality to this event hook.",
  "scrapedAt": "2025-10-22T00:02:05.142Z"
}