{
  "route": "framework/user/en/ui-testing",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/ui-testing",
  "title": "You can write UI tests using Cypress. It is a NodeJS based",
  "content": "You can write UI tests using Cypress. It is a NodeJS based\nfull-stack testing framework which doesn't rely on Selenium.\n\nTo write integration tests, create a .js file in the cypress/integration\ndirectory.\n\nExample\n\nHere is an example of an integration test to check insertion of a ToDo\n\ncontext('ToDo', () => {\n before(() => {\n cy.login('Administrator', 'admin');\n cy.visit('/desk');\n });\n\n it('creates a new todo', () => {\n cy.visit('/app/todo/new-todo-1');\n cy.fill_field('description', 'this is a test todo', 'Text Editor').blur();\n cy.get('.page-title').should('contain', 'Not Saved');\n cy.get('.primary-action').click();\n cy.visit('/desk#List/ToDo');\n cy.location('hash').should('eq', '/app/todo');\n cy.get('.list-row').should('contain', 'this is a test todo');\n });\n});\n\nRunning Cypress Locally\n\nCypress uses any chromium based browser installed on your system to run tests.\nEvery app has it's own cypress test suite. To run test for an app, run the\nfollowing command from the frappe-bench directory.\n\nbench --site [sitename] run-ui-tests [app]\n\nThis will open the Cypress Electron shell where you can run any test manually or\nrun all of the tests.\n\nYou can also run tests in headless mode.\n\n# run in headless mode\nbench --site [sitename] run-ui-tests [app] --headless\n\nTo enable cypress parallel testing you can pass --parallel flag.\nMore information on how cypress parallel tests work can be found here.\n\n# run tests parallelly\nbench --site [sitename] run-ui-tests [app] --parallel\n\nCode Coverage\n\nCode coverage helps to identify which lines of the source code were executed during the tests. In order to measure code coverage, the source code needs to be instrumented and this instrumented source code needs to be integrated with our test runner to collect the coverage and generate a report.\n\nFor Cypress tests in Frappe, the .js files are instrumented using Istanbul and the Cypress code-coverage plugin is used to merge coverage from each test and save the combined result.\n\nCode Instrumentation:\n\nIn order to compute which lines of the source code were executed, additional counters are inserted into the code through _instrumentation_. For example:\n\nBefore instrumentation:\n\nfunction foo(a, b) {\n if (a < b)\n return b - a;\n else\n return a - b;\n}\n\nAfter instrumentation:\n\ncov_1m1jljnmzu();\n\nfunction foo(a, b) {\n cov_1m1jljnmzu().f[0]++;\n cov_1m1jljnmzu().s[0]++;\n\n if (a < b) {\n cov_1m1jljnmzu().b[0][0]++;\n cov_1m1jljnmzu().s[1]++;\n return b - a;\n } else {\n cov_1m1jljnmzu().b[0][1]++;\n cov_1m1jljnmzu().s[2]++;\n return a - b;\n }\n}\n\nWhen using this modified (instrumented) source code for testing, these counters get incremented as the code is executed, and a coverage object is generated. The Cypress code-coverage plugin then handles the collected coverage and generates coverage reports.\n\nGenerating Code Coverage Report Locally:\n\nInstrument source code using istanbul/nyc :\n\nnpx nyc instrument -x 'frappe/public/dist/**' -x 'frappe/public/js/lib/**' -x '**/*.bundle.js' --compact=false --in-place frappe\n\nThis replaces the existing source code in the frappe folder with the instrumented source code. The -x flag is used to exclude specified paths. You can also use the -n flag to specify paths to be included. See here for more details about the nyc instrument command\nRun Cypress tests:\n\nbench --site test_site run-ui-tests frappe --with-coverage\n\nGenerate report:\n\nnpx nyc report --reporter=text\n\nSee here for alternate report formats\n\nTesting-Library Queries\n\nYou can also use Testing Library queries within your Cypress tests. Testing Library provides testing utilities that:\n\nMake it easier to write UI tests that resemble the way users interact with the app\nMake it easier to find elements in the DOM without knowing all the implementation details\nHelp keep the tests maintainable (so minor refactors don't break tests)\n\n See Testing Library Docs for more details about usage\n\nTesting Library provides several queries to find elements on a page. Here are some examples:\n\nByRole\n\nLook here for table of HTML elements and their default roles\n\n Query\n Element\n\n findByRole('button', {name: 'Save'})\n `` with accessible name = 'Save'\n\n findByRole('checkbox')\n ``\n\n findByRole('textbox')\n , _(Also matches other elements with default role='textbox')_\n\n findByRole('searchbox')\n <input type=search>\n\n findByRole('listbox')\n <select>, <datalist>\n\nByLabelText\n\n Query\n Element\n\n findByLabelText('Optimize')\n element associated with the label 'Optimize'\n\nByPlaceholderText\n\n Query\n Element\n\n findByPlaceholderText('Name')\n element with placeholder='Name'\n\nByText\n\n Query\n Element\n\n findByText('example.json')\n element with textContent='example.json'\n\nByDisplayValue\n\n Query\n Element\n\n findByDisplayValue('Option 1')\n <select> with selected <option> 'Option 1' _(Also matches <input> or <textarea> with matching value attribute)_\n\nByTitle\n\n Query\n Element\n\n findByTitle('Open Link')\n element with title='Open Link'\n\nByAltText\nByTestId",
  "scrapedAt": "2025-10-22T00:04:44.779Z"
}