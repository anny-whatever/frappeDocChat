{
  "route": "framework/user/en/api/database",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/api/database",
  "title": "frappe.db.get_list",
  "content": "frappe.db.get_list\n\nfrappe.db.get_list(doctype, filters, or_filters, fields, order_by, group_by, start, page_length)\n\nAlso aliased to frappe.get_list\n\nReturns a list of records from a doctype table. ORM Wrapper for a SELECT query. Will also apply user permissions for the records for the session user. Only returns the document names if the fields keyword argument is not given. By default this method returns a list of dicts, but, you can pluck a particular field by giving the pluck keyword argument:\n\nfrappe.db.get_list('Employee')\n\n# output\n[{'name': 'HR-EMP-00008'},\n {'name': 'HR-EMP-00006'},\n {'name': 'HR-EMP-00010'},\n {'name': 'HR-EMP-00005'}\n]\n\n# with pluck\nfrappe.db.get_list('Employee', pluck='name')\n\n# output\n['HR-EMP-00008',\n 'HR-EMP-00006',\n 'HR-EMP-00010',\n 'HR-EMP-00005'\n]\n\nCombining filters and other arguments:\n\nfrappe.db.get_list('Task',\n filters={\n 'status': 'Open'\n },\n fields=['subject', 'date'],\n order_by='date desc',\n start=10,\n page_length=20,\n as_list=True\n)\n\n# output\n(('Update Branding and Design', '2019-09-04'),\n('Missing Documentation', '2019-09-02'),\n('Fundraiser for Foundation', '2019-09-03'))\n\n# Tasks with date after 2019-09-08\nfrappe.db.get_list('Task', filters={\n 'date': ['>', '2019-09-08']\n})\n\n# Tasks with date between 2020-04-01 and 2021-03-31 (both inclusive)\nfrappe.db.get_list('Task', filters=[[\n 'date', 'between', ['2020-04-01', '2021-03-31']\n]])\n\n# Tasks with subject that contains \"test\"\nfrappe.db.get_list('Task', filters={\n 'subject': ['like', '%test%']\n})\n\n# Count number of tasks grouped by status\nfrappe.db.get_list('Task',\n fields=['count(name) as count', 'status'],\n group_by='status'\n)\n# output\n[{'count': 1, 'status': 'Working'},\n {'count': 2, 'status': 'Overdue'},\n {'count': 2, 'status': 'Open'},\n {'count': 1, 'status': 'Filed'},\n {'count': 20, 'status': 'Completed'},\n {'count': 1, 'status': 'Cancelled'}]\n\nfrappe.db.get_all\n\nfrappe.db.get_all(doctype, filters, or_filters, fields, order_by, group_by, start, page_length)\n\nAlso aliased to frappe.get_all\n\nSame as frappe.db.get_list but will fetch all records without applying permissions.\n\nfrappe.db.get_value\n\nfrappe.db.get_value(doctype, name, fieldname) or frappe.db.get_value(doctype, filters, fieldname)\n\nAlso aliased to frappe.get_value and frappe.db.get_values\n\nReturns a document's field value or a list of values.\n\n# single value\nsubject = frappe.db.get_value('Task', 'TASK00002', 'subject')\n\n# multiple values\nsubject, description = frappe.db.get_value('Task', 'TASK00002', ['subject', 'description'])\n\n# as dict\ntask_dict = frappe.db.get_value('Task', 'TASK00002', ['subject', 'description'], as_dict=1)\ntask_dict.subject\ntask_dict.description\n\n# with filters, will return the first record that matches filters\nsubject, description = frappe.db.get_value('Task', {'status': 'Open'}, ['subject', 'description'])\n\nfrappe.db.get_single_value\n\nfrappe.db.get_single_value(doctype, fieldname)\n\nReturns a field value from a Single DocType.\n\ntimezone = frappe.db.get_single_value('System Settings', 'timezone')\n\nfrappe.db.set_value\n\nfrappe.db.set_value(doctype, name, fieldname, value)\n\nAlso aliased to frappe.db.update\n\nSets a field's value in the database, does not call the ORM triggers but updates the modified timestamp (unless specified not to).\n\n# update a field value\nfrappe.db.set_value('Task', 'TASK00002', 'subject', 'New Subject')\n\n# update multiple values\nfrappe.db.set_value('Task', 'TASK00002', {\n 'subject': 'New Subject',\n 'description': 'New Description'\n})\n\n# update without updating the `modified` timestamp\nfrappe.db.set_value('Task', 'TASK00002', 'subject', 'New Subject', update_modified=False)\n\n This method won't call ORM triggers like validate and on_update. Use this method to update hidden fields or if you know what you are doing.\n\nfrappe.db.exists\n\nfrappe.db.exists(doctype, name)\n\nReturns true if a document record exists.\n\nPass doctype and docname:\n\nfrappe.db.exists(\"User\", \"jane@example.org\", cache=True)\n\nPass a dict of filters including the \"doctype\" key:\n\nfrappe.db.exists({\"doctype\": \"User\", \"full_name\": \"Jane Doe\"})\n\nPass the doctype and a dict of filters:\n\nfrappe.db.exists(\"User\", {\"full_name\": \"Jane Doe\"})\n\nfrappe.db.count\n\nfrappe.db.count(doctype, filters)\n\nReturns number of records for a given doctype and filters.\n\n# total number of Task records\nfrappe.db.count('Task')\n\n# total number of Open tasks\nfrappe.db.count('Task', {'status': 'Open'})\n\nfrappe.db.delete\n\nfrappe.db.delete(doctype, filters)\n\nDelete doctype records that match filters. This runs a DML command, which means it can be rolled back. If no filters specified, all the records of the doctype are deleted.\n\nfrappe.db.delete(\"Route History\", {\n \"modified\": (\"<=\", last_record_to_keep[0].modified),\n \"user\": user\n})\n\nfrappe.db.delete(\"Error Log\")\nfrappe.db.delete(\"__Test Table\")\n\nYou may pass the doctype name or an internal table name. Conventionally, internal tables in Frappe are prefixed with __. The API follows this. The above commands run an unconditional DELETE query over tables tabError Log and __Test Table.\n\nfrappe.db.truncate\n\nfrappe.db.truncate(doctype)\n\nTruncate a table in the database. This runs a DDL command TRUNCATE TABLE, a commit is triggered before the statement is executed. This action cannot be rolled back. You may want to use this for clearing out log tables periodically.\n\nfrappe.db.truncate(\"Error Log\")\nfrappe.db.truncate(\"__Test Table\")\n\nThe above commands run a TRUNCATE query over tables tabError Log and __Test Table.\n\nfrappe.db.commit\n\nfrappe.db.commit()\n\nCommits current transaction. Calls SQL COMMIT.\n\n In most cases you don't need to commit manually. Refer Frappe's Database transaction model below.\n\nfrappe.db.savepoint\n\nfrappe.db.savepoint(save_point)\n\nCreate a named savepoint to which you can later roll back to.\n\nfrappe.db.rollback\n\nfrappe.db.rollback()\n\nRollbacks current transaction. Calls SQL ROLLBACK.\n\n Frappe will automatically run frappe.db.rollback() if an exception is thrown during a Web Request of type POST or PUT. Use this if you have to rollback early in a transaction.\n\nfrappe.db.rollback(save_point=\"save_point_name\")\n\nRollback to a specific savepoint instead rolling back full transactions. This rollback won't undo changes done to filesytem and any other rollback watchers.\n\nfrappe.db.sql\n\nfrappe.db.sql(query, values, as_dict)\n\nExecute an arbitrary SQL query. This may be useful for complex server side reports with join statements, adjusting the database to new features, etc.\n\nExample:\n\nvalues = {'company': 'Frappe Technologies Inc'}\ndata = frappe.db.sql(\"\"\"\n SELECT\n acc.account_number\n gl.debit\n gl.credit\n FROM `tabGL Entry` gl\n LEFT JOIN `tabAccount` acc\n ON gl.account = acc.name\n WHERE gl.company = %(company)s\n\"\"\", values=values, as_dict=0)\n\n Avoid using this method as it will bypass validations and integrity checks. It's always better to use frappe.getdoc, frappe.db.getlist, etc., if possible.\n\nfrappe.db.multisql\n\nfrappe.db.multisql({'mariadb': mariadb_query, 'postgres': postgres_query})\n\nExecute the suitable SQL statement for any supported database engine.\n\nfrappe.db.rename_table\n\nfrappe.db.rename_table(old_name, new_name)\n\nExecutes a query to change table name. Specify the DocType or internal table's name directly to rename the table.\n\nExample:\n\nfrappe.db.rename_table(\"__internal_cache\", \"__temporary_cache\")\nfrappe.db.rename_table(\"todo\", \"ToDo\")\n\nThe second example should be used only if you understand the ramifications of it.\n\n Don't use this to rename DocType tables. Use frappe.rename_doc for that instead\n\nfrappe.db.describe\n\nfrappe.db.describe(doctype)\n\nReturns a tuple of the table description for given DocType.\n\nfrappe.db.change_column_type\n\nfrappe.db.change_column_type(doctype, column, new_type)\n\nChanges the type of column for specified DocType.\n\nfrappe.db.add_index\n\nfrappe.db.add_index(doctype, fields, index_name)\n\nCreates indexes for doctypes for the specified fields.\n\n Note: if you want an index on a TEXT or a BLOB field, you must specify a fixed length to do that.\n\nExample:\n\nfrappe.db.add_index(\"Notes\", [\"id(10)\", \"content(500)\"], index_name)\n\nfrappe.db.add_unique\n\nfrappe.db.add_unique(doctype, fields, constraint_name=None)\n\nCreates unique constraint for doctypes for the specified fields.\n\nExample:\n\nfrappe.db.add_unique(\"DoctypeName\",[\"field1\",\"field2\"])\n\nDatabase transaction hooks\n\n Note: This API is introduced in v15.\n\nFrappe provides hooks for running callbacks before/after transaction commands like commit/rollback are issued. These hooks are useful for:\n\nRolling back changes that are done outside of the database if the transaction is rolled back\nFlushing changes outside of the database only if the transaction is committed.\n\nThese hooks are :\n\nfrappe.db.before_commit.add(func: Callable)\nfrappe.db.after_commit.add(func: Callable)\nfrappe.db.before_rollback.add(func: Callable)\nfrappe.db.after_rollback.add(func: Callable)\n\nExample usage:\n\ndef create_file(self):\n self.write_file()\n # This ensures rollback if DB transaction is rolledback\n frappe.db.after_rollback.add(self.rollback_file)\n\ndef rollback_file(self):\n self.delete_file()\n\nDatabase transaction model\n\nFrappe's database abstractions implement a sane transaction model by default. So in most cases, you won't have to deal with SQL transactions manually. A broad description of this model is described below:\n\nWeb requests\n\nWhile performing POST or PUT, if any writes were made to the database, they are committed at end of the successful request.\nAJAX calls made using frappe.call are POST by default unless changed.\nGET requests do not cause an implicit commit.\nAny uncaught exception during handling of request will rollback the transaction.\n\nBackground/scheduled Jobs\n\nCalling a function as background or scheduled job will commit the transaction after successful completion.\nAny uncaught exception will cause rollback of the transaction.\n\nPatches\n\nSuccessful completion of the patch's execute function will commit the transaction automatically.\nAny uncaught exception will cause rollback of the transaction.\n\nUnit tests\n\nTransaction is committed after running one test module. Test module means any python test file like test_core.py.\nTransaction is also committed after finishing all tests.\nAny uncaught exception will exit the test runner, hence won't commit.\n\n Note: If you're catching exceptions anywhere, then database abstraction does not know that something has gone wrong hence you're responsible for the correct rollback of the transaction.",
  "scrapedAt": "2025-10-22T00:01:43.923Z"
}