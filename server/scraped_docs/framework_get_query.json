{
  "route": "framework/get_query",
  "sourceUrl": "https://docs.frappe.io/framework/get_query",
  "title": "get_query",
  "content": "The frappe.qb.get_query function provides a modern, safe, and expressive way to build database queries in Frappe. It leverages the power of the Pypika library while integrating seamlessly with Frappe's DocType metadata, permissions, and conventions. This guide will walk you through using frappe.qb.get_query from basic usage to more advanced scenarios.\n\nIntroduction\n\nWhile frappe.db.get_list and frappe.db.get_all have served Frappe well for many years and are capable of handling complex queries, their underlying code has grown complex over time, making them harder to maintain and extend. frappe.qb.get_query represents a modern approach to achieve similar results, built with better extensibility and maintainability in mind.\n\nGetting Started\n\nBasic Query Structure\n\nTo get started, you need to understand the basic structure of a query:\n\n# Get a query builder instance for the 'User' DocType\nquery = frappe.qb.get_query(\"User\")\n\n# Execute the query and fetch results\nusers = query.run(as_dict=True)\n\nBy default, if no fields are specified, it selects only the name field.\n\nSimple Example\n\n# Get all user names and emails\nquery = frappe.qb.get_query(\"User\", fields=[\"name\", \"email\"])\nusers = query.run(as_dict=True)\n# users will be like: [{'name': 'Administrator', 'email': 'admin@example.com'}, ...]\n\nField Selection\n\nBasic Field Selection\n\nUse the fields argument to specify which columns you want.\n\n# Select specific fields\nquery = frappe.qb.get_query(\"User\", fields=[\"name\", \"email\"])\n\n# You can also pass fields as a comma-separated string\nquery = frappe.qb.get_query(\"User\", fields=\"name, email\")\n\n# Or select all fields using '*'\nquery = frappe.qb.get_query(\"User\", fields=\"*\")\n\nUsing Aliases\n\nUse as within the field string to give fields aliases in the output.\n\nquery = frappe.qb.get_query(\n \"User\",\n fields=[\"name as user_name\", \"email as user_email\"]\n)\nusers = query.run(as_dict=True)\n# users will be like: [{'user_name': 'Administrator', 'user_email': 'admin@example.com'}, ...]\n\nLinked Document Fields\n\nIf you have a Link field, you can fetch fields from the linked document using dot notation: link_fieldname.target_fieldname. The query builder automatically adds the necessary LEFT JOIN.\n\n# Get Sales Order customer name (assuming 'customer' is a Link field to Customer DocType)\nquery = frappe.qb.get_query(\n \"Sales Order\",\n fields=[\"name\", \"customer.customer_name as customer_name\"],\n filters={\"name\": \"SO-00001\"}\n)\nso_data = query.run(as_dict=True)\n# so_data might be: [{'name': 'SO-00001', 'customer_name': 'Test Customer'}]\n\nChild Table Fields\n\nYou can access fields within a Child Table using dot notation: child_table_fieldname.child_doc_fieldname.\n\n# Get item code from Sales Order Item (assuming 'items' is the child table fieldname)\nquery = frappe.qb.get_query(\n \"Sales Order\",\n fields=[\"name\", \"items.item_code\"],\n filters={\"name\": \"SO-00001\"}\n)\n# This will likely return multiple rows if SO-00001 has multiple items\nso_items = query.run(as_dict=True)\n# so_items might be: [{'name': 'SO-00001', 'item_code': 'ItemA'}, {'name': 'SO-00001', 'item_code': 'ItemB'}]\n\nImportant: When selecting fields from child tables this way, the query performs a LEFT JOIN, potentially resulting in multiple rows for each parent document if the child table has multiple entries.\n\nFetching Child Table Records\n\nA more structured way to fetch child table data:\n\n# Get Sales Orders and their associated items\nquery = frappe.qb.get_query(\n \"Sales Order\",\n fields=[\n \"name\",\n \"customer\",\n {\"items\": [\"item_code\", \"qty\", \"rate\"]} # Fetch from 'items' child table\n ],\n filters={\"docstatus\": 1},\n limit=5\n)\n\nresults = query.run(as_dict=True)\n\n# Example result structure:\n# [\n# {\n# 'name': 'SO-00001',\n# 'customer': 'Customer A',\n# 'items': [\n# {'item_code': 'ItemA', 'qty': 2.0, 'rate': 100.0},\n# {'item_code': 'ItemB', 'qty': 1.0, 'rate': 50.0}\n# ]\n# },\n# {\n# 'name': 'SO-00002',\n# 'customer': 'Customer B',\n# 'items': [\n# {'item_code': 'ItemC', 'qty': 5.0, 'rate': 20.0}\n# ]\n# }\n# ]\n\nThis approach performs a separate query for the child records after fetching the parent records, efficiently grouping them by parent.\n\nSQL Functions in Fields\n\nTo use SQL functions in your select clauses, you can use dictionary-based syntax within the fields argument.\n\nAggregation Functions\n\n# COUNT - Count rows or non-null values\nquery = frappe.qb.get_query(\n \"User\",\n fields=[\"user_type\", {\"COUNT\": \"name\", \"as\": \"total_users\"}],\n group_by=\"user_type\"\n)\n\n# COUNT(*) - Count all rows including nulls\nquery = frappe.qb.get_query(\n \"Sales Invoice\",\n fields=[{\"COUNT\": \"'*'\", \"as\": \"total_invoices\"}]\n)\n\n# SUM - Calculate sum of numeric values\nquery = frappe.qb.get_query(\n \"Sales Invoice\",\n fields=[{\"SUM\": \"grand_total\", \"as\": \"total_sales\"}],\n filters={\"docstatus\": 1}\n)\n\n# AVG - Calculate average of numeric values\nquery = frappe.qb.get_query(\n \"Sales Invoice\",\n fields=[{\"AVG\": \"grand_total\", \"as\": \"avg_invoice_amount\"}],\n group_by=\"customer\"\n)\n\n# MAX - Find maximum value\nquery = frappe.qb.get_query(\n \"User\",\n fields=[{\"MAX\": \"creation\", \"as\": \"latest_user_date\"}]\n)\n\n# MIN - Find minimum value\nquery = frappe.qb.get_query(\n \"User\",\n fields=[{\"MIN\": \"creation\", \"as\": \"earliest_user_date\"}]\n)\n\nScalar Functions\n\n# ABS - Absolute value\nquery = frappe.qb.get_query(\n \"Journal Entry Account\",\n fields=[{\"ABS\": \"debit_in_account_currency\", \"as\": \"abs_amount\"}]\n)\n\n# IFNULL - Handle null values (takes two arguments)\nquery = frappe.qb.get_query(\n \"User\",\n fields=[{\"IFNULL\": [\"first_name\", \"'Unknown'\"], \"as\": \"display_name\"}]\n)\n\n# CONCAT - Concatenate strings (takes multiple arguments)\nquery = frappe.qb.get_query(\n \"User\",\n fields=[{\"CONCAT\": [\"first_name\", \"' '\", \"last_name\"], \"as\": \"full_name\"}]\n)\n\n# EXTRACT - Extract part of date/time (takes two arguments: unit and date)\nquery = frappe.qb.get_query(\n \"User\",\n fields=[{\"EXTRACT\": [\"'YEAR'\", \"creation\"], \"as\": \"creation_year\"}]\n)\n\n# NOW - Current timestamp (no arguments)\nquery = frappe.qb.get_query(\n \"User\",\n fields=[{\"NOW\": None, \"as\": \"current_time\"}]\n)\n\nFiltering\n\nBasic Filters\n\nThe filters argument allows you to add WHERE clauses.\n\nDictionary Filters (Equality)\n\nThis is the simplest and often preferred way for equality checks.\n\n# Get users with first_name 'Admin'\nquery = frappe.qb.get_query(\n \"User\",\n fields=[\"name\", \"email\"],\n filters={\"first_name\": \"Admin\"} # Simple key-value implies '='\n)\n\nDictionary Filters (Other Operators)\n\nFor operators other than =, use a dictionary where the value is a list [operator, value].\n\n# Get users created after a certain date\nquery = frappe.qb.get_query(\n \"User\",\n fields=[\"name\", \"creation\"],\n filters={\"creation\": [\">\", \"2023-01-01 00:00:00\"]}\n)\n\n# Get users whose name is like 'test%'\nquery = frappe.qb.get_query(\n \"User\",\n fields=[\"name\"],\n filters={\"name\": [\"like\", \"test%\"]}\n)\n\n# Get users whose name is in a list\nquery = frappe.qb.get_query(\n \"User\",\n fields=[\"name\"],\n filters={\"name\": [\"in\", [\"test1@example.com\", \"test2@example.com\"]]}\n)\n\n# Get users whose name is NOT in a list\nquery = frappe.qb.get_query(\n \"User\",\n fields=[\"name\"],\n filters={\"name\": [\"not in\", [\"Administrator\", \"Guest\"]]}\n)\n\nList Filters (Alternative Format)\n\nYou can also provide a list containing filter lists [[fieldname, operator, value]].\n\n# Get users created after a certain date (using list format)\nquery = frappe.qb.get_query(\n \"User\",\n fields=[\"name\", \"creation\"],\n filters=[[\"creation\", \">\", \"2023-01-01 00:00:00\"]]\n)\n\n# Multiple filters (combined with AND)\nquery = frappe.qb.get_query(\n \"User\",\n fields=[\"name\"],\n filters=[\n [\"enabled\", \"=\", 1],\n [\"user_type\", \"=\", \"System User\"]\n ]\n)\n\nFilter Operators\n\nfrappe.qb.get_query supports various operators:\n\n Operator String\n SQL Equivalent\n Example Usage (Dictionary Format)\n Example Usage (List Format)\n\n =\n =\n {\"name\": \"Test\"}\n [[\"name\", \"=\", \"Test\"]]\n\n !=\n !=\n {\"name\": [\"!=\", \"Test\"]}\n [[\"name\", \"!=\", \"Test\"]]\n\n >\n >\n {\"creation\": [\">\", \"2023-01-01\"]}\n [[\"creation\", \">\", \"2023-01-01\"]]\n\n <\n <\n {\"creation\": [\"<\", \"2023-01-01\"]}\n [[\"creation\", \"<\", \"2023-01-01\"]]\n\n >=\n >=\n {\"age\": [\">=\", 18]}\n [[\"age\", \">=\", 18]]\n\n <=\n <=\n {\"age\": [\"<=\", 65]}\n [[\"age\", \"<=\", 65]]\n\n like\n LIKE\n {\"subject\": [\"like\", \"%urgent%\"]}\n [[\"subject\", \"like\", \"%urgent%\"]]\n\n not like\n NOT LIKE\n {\"subject\": [\"not like\", \"spam%\"]}\n [[\"subject\", \"not like\", \"spam%\"]]\n\n in\n IN\n {\"status\": [\"in\", [\"Open\", \"Pending\"]]}\n [[\"status\", \"in\", [\"Open\", \"Pending\"]]]\n\n not in\n NOT IN\n {\"role\": [\"not in\", [\"Guest\"]]}\n [[\"role\", \"not in\", [\"Guest\"]]]\n\n is\n IS NULL or IS NOT NULL\n {\"customer\": [\"is\", \"set\"]} or {\"email\": [\"is\", \"not set\"]}\n [[\"customer\", \"is\", \"set\"]] or [[\"email\", \"is\", \"not set\"]]\n\n descendants of\n (Nested Set)\n {\"parent_account\": [\"descendants of\", \"Assets\"]}\n [[\"parent_account\", \"descendants of\", \"Assets\"]]\n\n ancestors of\n (Nested Set)\n {\"location\": [\"ancestors of\", \"Room 101\"]}\n [[\"location\", \"ancestors of\", \"Room 101\"]]\n\n not descendants of\n (Nested Set)\n {\"category\": [\"not descendants of\", \"Internal\"]}\n [[\"category\", \"not descendants of\", \"Internal\"]]\n\n not ancestors of\n (Nested Set)\n {\"territory\": [\"not ancestors of\", \"West Coast\"]}\n [[\"territory\", \"not ancestors of\", \"West Coast\"]]\n\nNote on is set / is not set: These check if a field has a value (IS NOT NULL and IS NULL respectively).\n\nFiltering on Linked Document Fields\n\nYou can filter based on fields in linked documents using dot notation: link_fieldname.target_fieldname.\n\n# Get Sales Orders where the linked Customer's territory is 'North America'\nquery = frappe.qb.get_query(\n \"Sales Order\",\n fields=[\"name\", \"customer\"],\n filters={\"customer.territory\": \"North America\"} # Filter on linked field\n)\nnorth_america_orders = query.run(as_dict=True)\n\nFiltering by Child Table Fields\n\nYou can filter parent records based on values in their child table records using dot notation: child_table_fieldname.target_fieldname.\n\n# Get Sales Orders that contain 'Item A' in their items table\n# Use distinct=True to ensure each Sales Order appears only once\nquery = frappe.qb.get_query(\n \"Sales Order\",\n fields=[\"name\", \"customer\"],\n filters={\"items.item_code\": \"Item A\"}, # Filter based on child table field\n distinct=True\n)\norders_with_item_a = query.run(as_dict=True)\n\nImportant: When filtering based on child table fields, use distinct=True if you only want unique parent records.\n\nNested Set Filters\n\nFor DocTypes that are trees (using lft and rgt columns, like Account, Territory, Warehouse, etc.), you can use special filters:\n\n# Get all accounts under 'Assets'\nquery = frappe.qb.get_query(\n \"Account\",\n fields=[\"name\"],\n filters={\"parent_account\": [\"descendants of\", \"Assets\"]}\n)\n\n# Get the parent territories of 'West Coast'\nquery = frappe.qb.get_query(\n \"Territory\",\n fields=[\"name\"],\n filters={\"parent_territory\": [\"ancestors of\", \"West Coast\"]}\n)\n\nLogical Operators (AND/OR)\n\nFor complex conditions, structure your filters as a list combining conditions with 'and' or 'or'.\n\n# Find users who are enabled AND have first name 'Admin'\nfilters_and = [\n [\"enabled\", \"=\", 1],\n \"and\",\n [\"first_name\", \"=\", \"Admin\"],\n]\nquery = frappe.qb.get_query(\"User\", filters=filters_and)\n\n# Find users who have first name 'Admin' OR 'Guest'\nfilters_or = [\n [\"first_name\", \"=\", \"Admin\"],\n \"or\",\n [\"first_name\", \"=\", \"Guest\"],\n]\nquery = frappe.qb.get_query(\"User\", filters=filters_or)\n\n# Combine AND and OR (use nested lists for grouping)\n# Find users who are enabled AND (have first name 'Admin' OR 'Guest')\nfilters_nested = [\n [\"enabled\", \"=\", 1],\n \"and\",\n [\n [\"first_name\", \"=\", \"Admin\"],\n \"or\",\n [\"first_name\", \"=\", \"Guest\"],\n ]\n]\nquery = frappe.qb.get_query(\"User\", filters=filters_nested)\n\nQuery Execution\n\nBasic Execution\n\nOnce you have the query object, execute it using .run():\n\n# Returns a list of tuples by default\nresults = query.run()\n\n# Returns a list of dictionaries\nresults = query.run(as_dict=True)\n\n# Returns a list of lists\nresults = query.run(as_list=True)\n\n# If selecting a single field, returns a flat list of values\nresults = query.run(pluck=True)\n\n# Print the generated SQL query and execution time\nresults = query.run(debug=True)\n\nGetting the SQL String\n\nYou can get the generated SQL string without executing:\n\n# Get the SQL string with values directly substituted (for debugging)\nsql_string = query.get_sql()\nprint(sql_string)\n# Example Output: SELECT `name`, `email` FROM `tabUser` WHERE `first_name`='Admin'\n\nUsing Iterators for Large Datasets\n\nWhen dealing with large datasets, use as_iterator=True to process results row by row without loading everything into memory:\n\n# Process a large number of tasks without loading all into memory\nquery = frappe.qb.get_query(\n \"Task\",\n fields=[\"name\", \"subject\", \"status\"],\n filters={\"status\": \"Open\"}\n)\n\n# Use unbuffered_cursor for optimal memory usage with the iterator\nwith frappe.db.unbuffered_cursor():\n task_iterator = query.run(as_iterator=True, as_dict=True)\n\n processed_count = 0\n for task in task_iterator:\n # Process each task dictionary one by one\n print(f\"Processing Task: {task['name']} - {task['subject']}\")\n processed_count += 1\n if processed_count % 1000 == 0:\n print(f\"Processed {processed_count} tasks...\")\n\nRequirements:\n\nYou must use as_iterator=True with either as_dict=True or as_list=True\nFor optimal memory efficiency, use within frappe.db.unbuffered_cursor() context manager\n\nOrdering, Grouping, and Pagination\n\nOrdering Results\n\nUse the order_by argument to sort results:\n\n# Order users by creation date, ascending\nquery = frappe.qb.get_query(\"User\", fields=[\"name\", \"creation\"], order_by=\"creation asc\")\n\n# Order by multiple fields\nquery = frappe.qb.get_query(\n \"Sales Invoice\",\n fields=[\"name\", \"customer\", \"grand_total\"],\n order_by=\"customer asc, grand_total desc\"\n)\n\nGrouping Results\n\nUse group_by for aggregation:\n\n# Count invoices per customer\nquery = frappe.qb.get_query(\n \"Sales Invoice\",\n fields=[\"customer\", {\"COUNT\": \"'*'\", \"as\": \"invoice_count\"}],\n filters={\"docstatus\": 1},\n group_by=\"customer\"\n)\nresults = query.run(as_dict=True)\n# results: [{'customer': 'Cust A', 'invoice_count': 5}, {'customer': 'Cust B', 'invoice_count': 3}, ...]\n\nPagination\n\nUse limit and offset for pagination:\n\n# Get the first 10 users\nquery = frappe.qb.get_query(\"User\", limit=10)\n\n# Get the next 10 users (page 2)\nquery = frappe.qb.get_query(\"User\", limit=10, offset=10)\n\nDistinct Results\n\nUse distinct=True to get unique rows:\n\n# Get distinct customers from submitted Sales Invoices\nquery = frappe.qb.get_query(\n \"Sales Invoice\",\n fields=[\"customer\"],\n filters={\"docstatus\": 1},\n distinct=True\n)\n\nPermissions\n\nThe ignore_permissions Flag\n\nBy default, frappe.qb.get_query ignores permissions (ignore_permissions=True). To enforce permissions, set ignore_permissions=False:\n\n# This query bypasses all permission checks (default behavior)\nquery_ignore = frappe.qb.get_query(\"DocType\", fields=[\"name\"], filters={\"istable\": 1})\n\n# This query enforces standard Frappe permissions for the current user\nquery_enforce = frappe.qb.get_query(\n \"DocType\",\n fields=[\"name\"],\n filters={\"istable\": 1},\n ignore_permissions=False # Explicitly enable permission checks\n)\n\ntry:\n results = query_enforce.run()\nexcept frappe.PermissionError:\n print(\"User does not have permission to read DocType!\")\n\nHow Permissions are Applied\n\nWhen ignore_permissions=False:\n\nRole Permissions: Checks if the user has 'read' or 'select' permission based on their roles.\nUser Permissions: Applies User Permissions (Allow/Restrict) defined for the DocType and linked DocTypes.\nSharing: Includes documents explicitly shared with the user.\nOwner Constraint: If the role permissions only grant access if_owner, the query restricts results to documents owned by the user.\nPermission Query Conditions: Applies conditions defined via Hooks or Server Scripts.\nField Level Security: Filters the selected fields, and does not allow fields used in filters, group_by, order_by if user does not have permlevel access. Also checks fields in link_field.target_field and child_field.target_field notations.\n\nField-Level Security\n\nWhen ignore_permissions=False:\n\nfields: Only fields accessible at the user's maximum permitted permlevel are included. Requesting inaccessible fields will silently remove the field from the selection.\nfilters: Filtering is only allowed on fields the user has permission to access. Attempting to filter on an inaccessible field will raise a frappe.PermissionError.\ngroup_by: Grouping is only allowed on fields the user has permission to access. Attempting to group by an inaccessible field will raise a frappe.PermissionError.\norder_by: Ordering is only allowed on fields the user has permission to access. Attempting to order by an inaccessible field will raise a frappe.PermissionError.\nLinked and Child Table Fields: When using link_field.target_field or child_field.target_field notation in any of the above clauses, the system checks permissions for both the link/child field itself and the target field in the linked/child DocType.\n\n# Assume 'published' field in Blog Post has permlevel 1\n# User 'test@example.com' only has permlevel 0 access\n\n# This works, but 'published' field is silently removed from results\nquery = frappe.qb.get_query(\n \"Blog Post\",\n fields=[\"name\", \"title\", \"published\"], # 'published' requested but inaccessible\n ignore_permissions=False,\n user=\"test@example.com\"\n)\n# result will contain 'name' and 'title', but NOT 'published'\n\n# This FAILS because filtering on 'published' is not allowed for this user\ntry:\n query = frappe.qb.get_query(\n \"Blog Post\",\n fields=[\"name\"],\n filters={\"published\": 1}, # Filtering on restricted field\n ignore_permissions=False,\n user=\"test@example.com\"\n )\n query.run()\nexcept frappe.PermissionError as e:\n print(f\"Permission error: {e}\")\n\nSpecifying User and Parent Context\n\n# Check permissions for a specific user\nquery = frappe.qb.get_query(\n \"Task\",\n ignore_permissions=False,\n user=\"test@example.com\" # Check permissions for this user\n)\n\n# Provide parent context for child DocTypes\nquery = frappe.qb.get_query(\n \"Sales Order Item\",\n fields=[\"item_code\", \"qty\"],\n filters={\"parent\": \"SO-00001\"},\n ignore_permissions=False,\n parent_doctype=\"Sales Order\" # Specify parent context for permission checks\n)\n\nAdvanced Features\n\nUsing Pypika Objects\n\nFor complex scenarios involving subqueries, advanced conditions, or functions not available in the dictionary syntax, you can use Pypika objects directly.\n\nPypika Objects in Fields\n\nfrom frappe.query_builder import Field, functions, Query\n\n# Define Pypika objects\nuser_table = frappe.qb.DocType(\"User\")\ntodo_table = frappe.qb.DocType(\"ToDo\")\n\n# Build a subquery to count open ToDos for each user\nopen_todo_subquery = (\n Query.from_(todo_table)\n .select(functions.Count(\"*\"))\n .where(todo_table.owner == user_table.name) # Correlated subquery\n .where(todo_table.status == \"Open\")\n).as_(\"open_todos_count\")\n\n# Use Pypika objects in fields\nquery = frappe.qb.get_query(\n \"User\",\n fields=[\n user_table.name,\n user_table.email,\n open_todo_subquery # Using the subquery object\n ],\n filters={\"user_type\": \"System User\"}\n)\nusers_with_counts = query.run(as_dict=True)\n\nPypika Objects in Filters\n\nfrom frappe.query_builder import Field, functions\n\n# Define Pypika objects\ntask_table = frappe.qb.DocType(\"Task\")\nmodified_field = task_table.modified\ncreation_field = task_table.creation\nsubject_field = task_table.subject\nstatus_field = task_table.status\n\n# Build complex criterion\ncomplex_filter = (\n (modified_field > creation_field) & (functions.Length(subject_field) > 10)\n) | (status_field == \"Cancelled\")\n\n# Use the Criterion object in filters\nquery = frappe.qb.get_query(\n \"Task\",\n fields=[\"name\", \"subject\", \"status\", \"creation\", \"modified\"],\n filters=complex_filter\n)\nresults = query.run(as_dict=True)\n\nRecord Locking\n\nFor use within database transactions where you need to prevent other transactions from modifying specific rows:\n\nBasic Locking\n\n# Lock specific Stock Ledger Entries\nquery = frappe.qb.get_query(\n \"Stock Ledger Entry\",\n fields=[\"name\", \"qty_after_transaction\"],\n filters={\"item_code\": \"ITEM001\", \"warehouse\": \"WH001\"},\n for_update=True # Adds FOR UPDATE clause, will wait if rows are locked\n)\nentries = query.run(as_dict=True)\n\nSkip Locked Rows\n\n# Skip rows that are already locked by another transaction\nquery = frappe.qb.get_query(\n \"ToDo\",\n fields=[\"name\", \"description\"],\n filters={\"status\": \"Pending\"},\n limit=5,\n order_by=\"creation asc\",\n for_update=True,\n skip_locked=True # Skip locked rows\n)\navailable_tasks = query.run(as_dict=True)\n\nNon-Blocking Lock Attempt\n\n# Fail immediately if rows are already locked\ntry:\n query = frappe.qb.get_query(\n \"System Settings\",\n fields=[\"name\"],\n filters={\"name\": \"System Settings\"},\n for_update=True,\n wait=False # Don't wait for locks\n )\n settings = query.run(as_dict=True)\nexcept Exception as e:\n print(f\"Could not acquire lock immediately: {e}\")\n\nSecurity Considerations\n\nfrappe.qb.get_query is designed with security in mind:\n\nField Validation: Field names are validated against strict patterns to prevent SQL injection.\nParameterization: Filter values are parameterized by the database driver.\nPermission Enforcement: Using ignore_permissions=False leverages Frappe's robust permission system.\n\nAlways ensure that any dynamic values used to construct filter keys or field names are properly sanitized if they originate from untrusted sources. Always rely on passing user input as filter values.\n\nWritten by Claude Sonnet 4. Reviewed by human.",
  "scrapedAt": "2025-10-22T00:01:55.171Z"
}