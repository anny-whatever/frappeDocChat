{
  "route": "framework/user/en/api/query-builder",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/api/query-builder",
  "title": "frappe.qb is a query builder written around PyPika to build a single interface for cross-db queries",
  "content": "frappe.qb is a query builder written around PyPika to build a single interface for cross-db queries\n\nWhile developing apps, you'll often need to retrieve some specific data from the database. One way to do this is to use frappe.db.sql and write raw SQL queries.\n\nMaybe something like\n\nresult = frappe.db.sql(\n f\"\"\"\n SELECT `path`,\n COUNT(*) as count,\n COUNT(CASE WHEN CAST(`is_unique` as Integer) = 1 THEN 1 END) as unique_count\n FROM `tabWeb Page View`\n WHERE `creation` BETWEEN {some_date} AND {some_later_date}\n \"\"\"\n)\n\nThe query builder API makes this easier by providing a simple pythonic API to build SQL queries without limiting the flexibility of handwritten SQL.\n\nThe same query in the query builder would look something like\n\nimport frappe\nfrom frappe.query_builder import DocType\nfrom frappe.query_builder.functions import Count\nfrom pypika.terms import Case\n\nWebPageView = DocType(\"Web Page View\") # you can also use frappe.qb.DocType to bypass an import\n\ncount_all = Count('*').as_(\"count\")\ncase = Case().when(WebPageView.is_unique == \"1\", \"1\")\ncount_is_unique = Count(case).as_(\"unique_count\")\n\nresult = (\n frappe.qb.from_(WebPageView)\n .select(WebPageView.path, count_all, count_is_unique)\n .where(Web_Page_View.creation[some_date:some_later_date])\n).run()\n\nfrappe.qb\n\nReturns a Pypika query object which lets you build queries. Queries built using this object will be a\ntype from pypika.dialects, sprinkled with some Frappe sugar. Some of its methods are:\n\nfrappe.qb.from_(doctype)\n\nlets you construct a from query to select data\n\nSelect query\n\nquery = frappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone')\n\nThe SQL query built is\n\nSELECT `id`,`fname`,`lname`,`phone` FROM `tabCustomer`\n\nA complex Select example\n\ncustomers = frappe.qb.DocType('Customer')\nq = (\n frappe.qb.from_(customers)\n .select(customers.id, customers.fname,customers.lname, customers.phone)\n .where((customers.fname == 'Max') | (customers.id.like('RA%')) )\n .where(customers.lname == 'Mustermann')\n)\n\nThe SQL query built is\n\nSELECT `id`,`fname`,`lname`,`phone` FROM `tabCustomer` WHERE (`fname`='Max' OR `id` LIKE 'RA%') AND `lname`='Mustermann'\n\nSome noteworthy things\n\nWe have created a customers variable to refer to the table in the query.\nSelect can take any number of arguments, selecting various Fields.\nThe '|' (pipe) or '&' (ampersand) operators can be used to refer to 'OR' or 'AND'.\nChaining the where() method appends 'AND' by default\n\nYou can read more about the other functions at the Pypika repo.\n\nfrappe.qb.Doctype(name_of_table)\n\nReturns a PyPika table object which can be used elsewhere. It will automatically add 'tab' if necessary.\n\nfrappe.qb.Table(name_of_table)\n\nDoes the same thing as frappe.qb.DocType but will not append 'tab'. It's intended to be used with '__Auth' like tables.\n\n Note: You should only use this if you know what you are doing.\n\nfrappe.qb.Field(name_of_coloum)\n\nReturn a PyPika field object, this represents a column. They are usually used to compare columns with values.\n\nOne example would be\n\nlname = frappe.qb.Field(\"lname\")\nq = frapppe.qb.from_(\"customers\").select(\"*\").where(lname == 'Mustermann')\n\nExecuting queries\n\nQueries built using the frappe.qb namespace are PyPika objects. They will have to be converted to string objects so that your database management system can recognize them.\n\nTo check how your query object translates, you can type cast it with str or use the .get_sql method they come with.\n\nquery = frappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone')\n\nstr(query)\n# SELECT \"id\",\"fname\",\"lname\",\"phone\" FROM \"tabCustomer\"\n\nquery.get_sql()\n# SELECT \"id\",\"fname\",\"lname\",\"phone\" FROM \"tabCustomer\"\n\nstr(query) == query.get_sql()\n# True\n\nWalk method\n\nAll queries built through frappe.qb are parameterized by default. All input fields, raw values, and functions are separated as Named parameters and sent to the database as a dictionary. Parameterization is done to sanitize queries which would prevent SQL injections.\n\nYou use the walk method to check out which parts are parameterized. It returns the parameterized query and the corresponding dictionary.\n\ndoctype = frappe.qb.DocType(\"DocType\")\n\nfrappe.qb.from_(doctype).select('*').where(doctype.name == \"somename\").walk()\n# ('SELECT * FROM `tabDocType` WHERE `name`=%(param1)s', {'param1': 'somename'})\n\nRun method\n\nThis is the most preferred method to execute your queries. Every valid query has the run method which you\nmay use to execute the query with.\n\nfrappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone').run()\n\nThe run method accepts kwargs which will be passed on while the query is being executed. You may pass whatever options are available in frappe.db.sql, through the run method.\n\nTo run debug on your query, or get the result in the form of List[Dict], you may use the following respectively:\n\nIn [7]: frappe.qb.from_('ToDo').select('name').run(debug=True)\nSELECT \"name\" FROM \"tabToDo\"\nExecution time: 0.0 sec\nOut[7]: [('8d765f73a2',)]\n\nIn [8]: frappe.qb.from_('ToDo').select('name').run(as_dict=True)\nOut[8]: [{'name': '8d765f73a2'}]\n\n The run method internally calls the lower level frappe.db.sql API.\n\nfrappe.db.sql\n\nou may choose to directly pass your query objects to frappe.db.sql too. This ignores permisions and paramaterisation of queries.\n\nquery = frappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone')\nfrappe.db.sql(query)\n\nfrappe.query_builder.functions\n\nThis module provides standard functions you might need while building queries, like Count() and Sum().\n\nJoins and Sub-queries\n\nYou can check pypika documentation to join tables and add subqueries. Instead of Table, use frappe.qb.DocType\n\nExample:\n\nHasRole = frappe.qb.DocType('Has Role')\nCustomRole = frappe.qb.DocType('Custom Role')\n\nquery = (frappe.qb.from_(HasRole)\n .inner_join(CustomRole)\n .on(CustomRole.name == HasRole.parent)\n .select(CustomRole.page, HasRole.parent, HasRole.role))\n\nSimple functions\n\nSay you want to count all the entries in a Notes table. You could do something like\n\nfrom frappe.query_builder.functions import Count\n\nNotes = frappe.qb.DocType(\"Notes\")\ncount_pages = Count(Notes.content).as_(\"Pages\")\n\nresult = frappe.qb.from_(Notes).select(count_pages).run(as_dict=True)\n\nCustom Functions\n\nfrappe.query_builder.functions is a superset of pypika.functions, so it has all PyPika functions and some custom ones we made. You can make your custom functions by importing the CustomFunction class from PyPika\n\nOne implementation of the DateDiff function\n\nfrom pypika import CustomFunction\n\ncustomers = Tables('Customer')\nDateDiff = CustomFunction('DATE_DIFF', ['interval', 'start_date', 'end_date'])\n\nq = Query.from_(customers).select(\n DateDiff('day', customers.created_date, customers.updated_date)\n)\n\nIf we print q, we would get\n\nSELECT DATE_DIFF('day',\"created_date\",\"updated_date\") FROM \"Customer\"\n\n Notice how we specify arguments and the actual SQL text. The exact format might not work for more complex functions. The advanced section covers more complicated methods.\n\nConstant Column\n\nConstantColumn is a class to define a pseudo column with a constant value. \n\nfrom frappe.query_builder.custom import ConstantColumn\n\nfrappe.qb.from_(\"DocType\").select(\"name\", ConstantColumn(\"john\").as_(\"user\"))\n# SELECT `name`,'john' `user` FROM `tabDocType`\n\nHere we define a column user with the value \"john.\"\n\nAdvanced\n\nSpecial functions\n\nOne such function is Match Against. It's different because it has a chained against argument. To implement something like this you need to inherit from PyPika's DistinctOptionFunction class.\n\nThe current MATCH class looks something like\n\nfrom pypika.functions import DistinctOptionFunction\nfrom pypika.utils import builder\n\nclass MATCH(DistinctOptionFunction):\n def __init__(self, column: str, *args:\n super(MATCH, self)._init_(\" MATCH\", column, *args)\n self._Against = False\n\n def get_function_sql(self, **kwargs):\n s = super(DistinctOptionFunction, self).get_function_sql(**kwargs)\n\n if self._Against:\n return f\"{s} AGAINST (f'+{self._Against}*') IN BOOLEAN MODE)\"\n return s\n\n @builder\n def Against(self, text: str):\n self._Against = text\n\nThe __init__() method works similar to CustomFunction class above. You mention all the arguments and the SQL text.\nThe Against() method only stores a value that will be used in the get_function_sql()\nIt also has the @builder wrapper. In short, it lets these functions be chainable by making a copy of the object.\nWe have wrapped the get_function_sql() method, which allows us to append the required SQL text for Against.\nthis can further be extended to use any number other chains.\n\nIn use, the Match class looks like this\n\nfrom frappe.query_builder.functions import Match\n\nmatch = Match(\"Coloum name\").Against(\"Some_text_match\")\n# MATCH('Coloum name') AGAINST ('+Some_text_match*' IN BOOLEAN MODE)\n\nUtils\n\nImportMapper(dict)\n\nIn the rare case where you have different functions for different SQL dialects, Which do the same thing, you can use the ImportMapper Utility. It maps functions based on the SQL dialect, so one query works across different SQL dialects.\n\nIt takes in a dict which maps functions to databases.\n\nFor example the the mapping for GroupConat looks like this\n\nfrom frappe.query_builder.utils import ImportMapper, db_type_is\nfrom frappe.query_builder.custom import GROUP_CONCAT, STRING_AGG\n\nGroupConcat = ImportMapper(\n {\n db_type_is.MARIADB: GROUP_CONCAT,\n db_type_is.POSTGRES: STRING_AGG\n }\n)",
  "scrapedAt": "2025-10-22T00:01:54.026Z"
}