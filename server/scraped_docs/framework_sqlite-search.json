{
  "route": "framework/sqlite-search",
  "sourceUrl": "https://docs.frappe.io/framework/sqlite-search",
  "title": "sqlite-search",
  "content": "SQLite Search is a full-text search framework for Frappe applications that provides advanced search capabilities using SQLite's FTS5 (Full-Text Search) engine. It offers features like spelling correction, time-based recency scoring, custom ranking, permission-aware filtering, and extensible scoring pipelines.\n\nTable of Contents\n\nQuick Start\nHow It Works\nConfiguration\nFeatures & Customization\nAPI Reference\n\nQuick Start\n\n1. Create a Search Class\n\nCreate a search implementation by extending SQLiteSearch:\n\n# my_app/search.py\nfrom frappe.search.sqlite_search import SQLiteSearch\n\nclass MyAppSearch(SQLiteSearch):\n # Database file name\n INDEX_NAME = \"my_app_search.db\"\n\n # Define the search schema\n INDEX_SCHEMA = {\n \"metadata_fields\": [\"project\", \"owner\", \"status\"],\n \"tokenizer\": \"unicode61 remove_diacritics 2 tokenchars '-_'\",\n }\n\n # Define which doctypes to index and their field mappings\n INDEXABLE_DOCTYPES = {\n \"Task\": {\n \"fields\": [\"name\", {\"title\": \"subject\"}, {\"content\": \"description\"}, \"modified\", \"project\", \"owner\", \"status\"],\n },\n \"Issue\": {\n \"fields\": [\"name\", \"title\", \"description\", {\"modified\": \"last_updated\"}, \"project\", \"owner\"],\n \"filters\": {\"status\": (\"!=\", \"Closed\")}, # Only index non-closed issues\n },\n }\n\n def get_search_filters(self):\n \"\"\"Return permission filters for current user\"\"\"\n # Get projects accessible to current user\n accessible_projects = frappe.get_all(\n \"Project\",\n filters={\"owner\": frappe.session.user},\n pluck=\"name\"\n )\n\n if not accessible_projects:\n return {\"project\": []} # No access\n\n return {\"project\": accessible_projects}\n\n2. Register the Search Class\n\nAdd your search class to hooks.py:\n\n# my_app/hooks.py\nsqlite_search = ['my_app.search.MyAppSearch']\n\n3. Create API Endpoint\n\nCreate a whitelisted method to expose search functionality:\n\n# my_app/api.py\nimport frappe\nfrom my_app.search import MyAppSearch\n\n@frappe.whitelist()\ndef search(query, filters=None):\n search = MyAppSearch()\n result = search.search(query, filters=filters)\n\n return result\n\n4. Build the Index\n\nBuild the search index programmatically or via console:\n\nfrom my_app.search import MyAppSearch\nsearch = MyAppSearch()\nsearch.build_index()\n\nHow It Works\n\n1. Indexing Process\n\nFull Index Building\n\nWhen you call build_index(), the framework performs a complete index rebuild:\n\nDatabase Preparation: Creates a temporary SQLite database with FTS5 tables configured according to your schema\nDocument Collection: Queries all specified doctypes using the configured field mappings and filters\nDocument Processing: For each document:\n\nExtracts and maps fields according to INDEXABLE_DOCTYPES configuration\nCleans HTML content using BeautifulSoup to extract plain text\nApplies custom document preparation logic if prepare_document() is overridden\nValidates required fields (title, content) are present\n\nBatch Insertion: Inserts processed documents into the FTS5 index in batches for performance\nVocabulary Building: Constructs a spelling correction dictionary from all indexed text\nAtomic Replacement: Replaces the existing index database with the new one atomically\n\nIndividual Document Indexing\n\nFor real-time updates using index_doc() or remove_doc():\n\nSingle Document Processing: Retrieves and processes one document using the same field mapping logic\nIncremental Update: Updates the existing FTS5 index by inserting, updating, or deleting the specific document\nVocabulary Update: Updates the spelling dictionary with new terms from the document\n\n2. Search Process\n\nWhen a user performs a search using search(), the framework executes these steps:\n\nPermission Filtering: Calls get_search_filters() to determine what documents the current user can access\nQuery Preprocessing:\n\nValidates the search query is not empty\nCombines user-provided filters with permission filters\n\nSpelling Correction:\n\nAnalyzes query terms against the vocabulary dictionary\nUses trigram similarity to suggest corrections for misspelled words\nExpands the original query with corrected terms\n\nFTS5 Query Execution:\n\nConstructs an FTS5-compatible query string\nExecutes the full-text search against the SQLite database\nApplies metadata filters (status, owner, project, etc.)\nRetrieves raw results with BM25 scores\n\nResults Processing:\n\nCustom Scoring: Applies the scoring pipeline to calculate final relevance scores\n\nBase BM25 score processing\nTitle matching boosts (exact and partial matches)\nRecency boosting based on document age\nCustom scoring functions (doctype-specific, priority-based, etc.)\n\nRanking: Sorts results by final scores and assigns rank positions\nContent Formatting: Generates content snippets and highlights matching terms\n\nConfiguration\n\nINDEX_SCHEMA\n\nDefines the structure of your search index:\n\nINDEX_SCHEMA = {\n # Text fields that will be searchable (defaults to [\"title\", \"content\"])\n \"text_fields\": [\"title\", \"content\"],\n\n # Metadata fields stored alongside text content for filtering\n \"metadata_fields\": [\"project\", \"owner\", \"status\", \"priority\"],\n\n # FTS5 tokenizer configuration\n \"tokenizer\": \"unicode61 remove_diacritics 2 tokenchars '-_@.'\"\n}\n\nINDEXABLE_DOCTYPES\n\nSpecifies which doctypes to index and how to map their fields:\n\nINDEXABLE_DOCTYPES = {\n \"Task\": {\n # Field mapping\n \"fields\": [\n \"name\",\n {\"title\": \"subject\"}, # Maps subject field to title\n {\"content\": \"description\"}, # Maps description field to content\n {\"modified\": \"creation\"}, # Use creation instead of modified for recency boost\n \"project\",\n \"owner\"\n ],\n\n # Optional filters to limit which records are indexed\n \"filters\": {\n \"status\": (\"!=\", \"Cancelled\"),\n \"docstatus\": (\"!=\", 2)\n }\n }\n}\n\nField Mapping Rules\n\nString fields: Direct mapping \"field_name\"\nAliased fields: Dictionary mapping {\"schema_field\": \"doctype_field\"}\nRequired fields: title and content fields must be present or explicitly mapped (e.g., {\"title\": \"subject\"})\nAuto-added fields: doctype and name are automatically included\nModified field: Added automatically if used in any doctype configuration. Used for recency boosting - if you want to use a different timestamp field (like creation or last_updated), map it to modified using {\"modified\": \"creation\"}\n\nFeatures & Customization\n\nPermission Filtering\n\nImplement get_search_filters() to control access:\n\ndef get_search_filters(self):\n \"\"\"Return filters based on user permissions\"\"\"\n user = frappe.session.user\n\n if user == \"Administrator\":\n return {} # No restrictions\n\n # Example: User can only see their own and public documents\n return {\n \"owner\": user,\n \"status\": [\"Active\", \"Published\"]\n }\n\nCustom Scoring\n\nCreate custom scoring functions to influence search relevance:\n\nclass MyAppSearch(SQLiteSearch):\n ...\n\n @SQLiteSearch.scoring_function\n def _get_priority_boost(self, row, query, query_words):\n \"\"\"Boost high-priority items\"\"\"\n priority = row.get(\"priority\", \"Medium\")\n\n if priority == \"High\":\n return 1.5\n if priority == \"Medium\":\n return 1.1\n return 1.0\n\nRecency Boosting\n\nThe framework automatically provides time-based recency boosting using the modified field:\n\n# The modified field is used for calculating document age\n# Recent documents get higher scores:\n# - Last 24 hours: 1.8x boost\n# - Last 7 days: 1.5x boost\n# - Last 30 days: 1.2x boost\n# - Last 90 days: 1.1x boost\n# - Older documents: gradually decreasing boost\n\n# If your doctype uses a different timestamp field, map it to modified:\nINDEXABLE_DOCTYPES = {\n \"GP Discussion\": {\n \"fields\": [\"name\", \"title\", \"content\", {\"modified\": \"last_post_at\"}, \"project\"],\n },\n \"Article\": {\n \"fields\": [\"name\", \"title\", \"content\", {\"modified\": \"published_date\"}, \"category\"],\n }\n}\n\nDocument Preparation\n\nOverride prepare_document() for custom document processing:\n\ndef prepare_document(self, doc):\n \"\"\"Custom document preparation\"\"\"\n document = super().prepare_document(doc)\n if not document:\n return None\n\n # Add computed fields\n if doc.doctype == \"Task\":\n # Combine multiple fields into content\n content_parts = [\n doc.description or \"\",\n doc.notes or \"\",\n \"\\n\".join([comment.content for comment in doc.get(\"comments\", [])])\n ]\n document[\"content\"] = \"\\n\".join(filter(None, content_parts))\n\n # set fields that might be stored in another table\n document[\"category\"] = get_category_for_task(doc)\n\n return document\n\nSpelling Correction\n\nThe framework includes built-in spelling correction using trigram similarity:\n\n# Spelling correction happens automatically\nsearch_result = search.search(\"projetc managment\") # Will find \"project management\"\n\n# Access correction information\nprint(search_result[\"summary\"][\"corrected_words\"])\n# Output: {\"projetc\": \"project\", \"managment\": \"management\"}\n\nContent Processing\n\nHTML content is automatically cleaned and processed using BeautifulSoup:\n\n# Complex HTML content like this:\nhtml_content = \"\"\"\n<div class=\"article\">\n <h1>API Documentation</h1>\n <p>Learn how to integrate with our <a href=\"/api\">REST API</a>.</p>\n <img src=\"/images/api-flow.png\" alt=\"API workflow diagram\" />\n <ul>\n <li><strong>Authentication:</strong> Use <code>Bearer tokens</code></li>\n <li>Rate limiting: <em>1000 requests/hour</em></li>\n </ul>\n <blockquote>See our <a href=\"/examples\">code examples</a> for details.</blockquote>\n <table><tr><td>Method</td><td>POST</td></tr></table>\n <script>analytics.track('page_view');</script>\n <style>.hidden { display: none; }</style>\n</div>\n\"\"\"\n\n# Is automatically converted to clean, searchable plain text:\n\"\"\"\nAPI Documentation\n\nLearn how to integrate with our REST API.\n\nAuthentication: Use Bearer tokens\nRate limiting: 1000 requests/hour\n\nSee our code examples for details.\n\nMethod POST\n\"\"\"\n\n# The cleaning process:\n# 1. Removes all HTML tags (<div>, <h1>, <strong>, <code>, etc.)\n# 2. Strips out scripts, styles, and non-content elements\n# 3. Extracts link text while removing href URLs\n# 4. Normalizes whitespace and line breaks\n\nTitle-Only Search\n\nresults = search.search(\"project update\", title_only=True)\n\nAdvanced Filtering\n\naccessible_projects = ['PROJ001', 'PROJ002', ...]\n\nfilters = {\n \"project\": accessible_projects, # Multiple values (IN clause)\n \"owner\": current_user, # Single value (= clause)\n}\n\nresults = search.search(\"bug fix\", filters=filters)\n\nAutomatic Index Handling\n\nThe framework handles index building and maintenance automatically when you register your search class:\n\n# hooks.py\nsqlite_search = ['my_app.search.MyAppSearch']\n\nWhat the framework does automatically:\n\nPost-Migration Index Building: Builds the search index automatically after running bench migrate\nPeriodic Index Verification: Checks every 15 minutes that the index exists and rebuilds if missing\nReal-time Document Updates: Automatically calls index_doc() and remove_doc() on document lifecycle events (insert, update, delete) for all doctypes defined in your INDEXABLE_DOCTYPES\n\nManual Index Handling\n\nIf you prefer to have manual control over the lifecycle of indexing, then you can simply opt out of automatic index handling by not registering the search class in sqlite_search hook.\n\nfrom my_app.search import MyAppSearch\n\ndef build_index_in_background():\n \"\"\"Manually trigger background index building\"\"\"\n search = MyAppSearch()\n if search.is_search_enabled() and not search.index_exists():\n frappe.enqueue(\"my_app.search.build_index\", queue=\"long\")\n\n# hooks.py\nscheduler_events = {\n # Custom scheduler (if you want different timing)\n \"daily\": [\"my_app.search.build_index_if_not_exists\"],\n}\n\nAPI Reference\n\nsearch(query, title_only=False, filters=None)\n\nMain search method that returns formatted results.\n\nParameters:\n- query (str): Search query text\n- title_only (bool): Search only in title fields\n- filters (dict): Additional filters to apply\n\nReturns:\n\n{\n \"results\": [\n {\n \"doctype\": \"Task\",\n \"name\": \"TASK-001\",\n \"title\": \"Fix login bug\",\n \"content\": \"User cannot login after password reset...\",\n \"score\": 0.85,\n \"original_rank\": 3, # original bm25 rank\n \"rank\": 1, # modified rank after custom scoring pipeline\n # ... other metadata fields\n }\n ],\n \"summary\": {\n \"duration\": 0.023,\n \"total_matches\": 15,\n \"returned_matches\": 15,\n \"corrected_words\": {\"loggin\": \"login\"},\n \"corrected_query\": \"Fix login bug\",\n \"title_only\": False,\n \"filtered_matches\": 15,\n \"applied_filters\": {\"status\": [\"Open\"]}\n }\n}\n\nbuild_index()\n\nBuild the complete search index from scratch.\n\nindex_doc(doctype, docname)\n\nIndex a single document.\n\nremove_doc(doctype, docname)\n\nRemove a single document from the index.\n\nis_search_enabled()\n\nCheck if search is enabled (override to add disable logic).\n\nindex_exists()\n\nCheck if the search index exists.\n\nget_search_filters()\n\nMust be implemented by subclasses. Return filters for the current user.\n\nReturns:\n\n{\n \"field_name\": \"value\", # Single value\n \"field_name\": [\"val1\", \"val2\"], # Multiple values\n}\n\nscoring_function()\n\nUse the @SQLiteSearch.scoring_function decorator to mark a function as a scoring function.",
  "scrapedAt": "2025-10-22T00:01:56.238Z"
}