{
  "route": "framework/user/en/guides/caching",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/guides/caching",
  "title": "caching",
  "content": "One of the batteries included in Frappe Framework is inbuilt caching using Redis. Redis is fast, simple to use, in-memory key-value storage. Redis with Frappe Framework can be used to speed up repeated long-running computations or avoid database queries for data that doesn't change often.\n\nRedis is spawned as a separate service by the bench and each Frappe web/background worker can connect to it using frappe.cache.\n\n Note: On older versions of Frappe, you may need to use frappe.cache() instead of frappe.cache to access Redis connection.\n\nRedis Data Types and Usage\n\nRedis supports many data types, but here we will only cover a few most used datatypes:\n\nStrings are the most popular and most used datatype in Redis. They are stored as key-value pairs.\n\nIn [1]: frappe.cache.set_value(\"key\", \"value\")\n\nIn [2]: frappe.cache.get_value(\"key\")\nOut[2]: 'value'\n\nHashes are used to represent complicated objects, fields of which can be updated separately without sending the entire object. You can imagine Hashes as dictionaries stored on Redis.\n\n# Get fields separately\nIn [1]: frappe.cache.hset(\"user|admin\", \"name\", \"Admin\")\nIn [2]: frappe.cache.hset(\"user|admin\", \"email\", \"admin@example.com\")\n\n# Get single field value\nIn [3]: frappe.cache.hget(\"user|admin\", \"name\")\nOut[3]: 'Admin'\n\n# Or retrieve all fields at once.\nIn [4]: frappe.cache.hgetall(\"user|admin\")\nOut[4]: {'name': 'Admin', 'email': 'admin@example.com'}\n\nCached Documents\n\nFrappe has an inbuilt function for getting documents from the cache instead of the database.\n\nGetting a document from the cache is usually faster, so you should use them when the document doesn't change that often. A common usage for this is getting user configured settings.\n\nsystem_settings = frappe.get_cached_doc(\"System Settings\")\n\nCached documents are automatically cleared using \"best-effort\" cache invalidation.\n\nWhenever Frappe's ORM encounters a change using doc.save or frappe.db.set_value, it clears the related document's cache. However, this isn't possible if a raw query to the database is issued.\n\nNote: Manual cache invalidation can be done using frappe.clear_document_cache(doctype, name).\n\nImplementing Custom Caching\n\nWhen you're dealing with a long expensive computation, the outcome of which is deterministic for the same inputs then it might make sense to cache the output.\n\nLet's attempt to implement a custom cache in this toy function which is slow.\n\ndef slow_add(a, b):\n import time; time.sleep(1) # Fake workload\n return a + b\n\nThe most important part of implementing custom caching is generating a unique key. In this example the outcome of the cached value is dependent on two input variables, hence they should be part of the key.\n\ndef slow_add(a, b):\n key = f\"slow_addition|{a}+{b}\" # unique key representing this computation\n\n # If this key exists in cache, then return value\n if cached_value := frappe.cache.get_value(key):\n return cached_value\n\n import time; time.sleep(1) # Fake workload\n result = a + b\n\n # Set the computed value in cache so next time we dont have to do the work\n frappe.cache.set_value(key, result)\n\n return result\n\nCache Invalidation\n\nTwo strategies are recommended for avoiding stale cache issues:\n\nSetting short TTL while setting cached values.\n\n# This cached value will automatically expire in one hour\nfrappe.cache.set_value(key, result, expires_in_sec=60*60)\n\nManually clearing the cache when cached values are modified.\n\nfrappe.cache.delete_value(key) # `frappe.cache.hdel` if using hashes.\n\n@redis_cache decorator\n\nFrappe provides a decorator to automatically cache the results of a function call.\n\nYou can use it to quickly implement caching on top of any existing function which might be slow.\n\nIn [1]: def slow_function(a, b):\n ...: import time; time.sleep(1) # fake expensive computation\n ...: return a + b\n ...:\n\nIn [2]: # This takes 1 second to execute every time.\n ...: %time slow_function(40, 2)\n ...:\nWall time: 1 s\nOut[2]: 42\n\nIn [3]: %time slow_function(40, 2)\nWall time: 1 s\nOut[3]: 42\n\nIn [4]: from frappe.utils.caching import redis_cache\n ...:\n\nIn [5]: @redis_cache\n ...: def slow_function(a, b):\n ...: import time; time.sleep(1) # fake expensive computation\n ...: return a + b\n ...:\n\nIn [6]: # Now first call takes 1 second, but all subsequent calls return instantly.\n ...: %time slow_function(40, 2)\n ...:\nWall time: 1 s\nOut[6]: 42\n\nIn [7]: %time slow_function(40, 2)\n ...:\nWall time: 897 Âµs\nOut[7]: 42\n\nCache Invalidation\n\nThere are two ways to invalidate cached values from @redis_cache.\n\nSetting appropriate expiry period (TTL in seconds) so cache invalidates automatically after some time. Example: @redis_cache(ttl=60) will cause cached value to expire after 60 seconds.\nManual clearing of cache. This is done by calling function's clear_cache method.\n\nfrom frappe.utils.caching import redis_cache\n\n@redis_cache\ndef slow_function(...):\n ...\n\ndef invalidate_cache():\n slow_function.clear_cache()\n\nFrappe's Redis Setup\n\nBench sets up Redis by default. You will find Redis config in {bench}/config/ directory.\n\nBench also configures Procfile and supervisor configuration file to launch Redis server when the bench is started.\n\nredis_cache: redis-server config/redis_cache.conf\n\nA sample config looks like this:\n\ndbfilename redis_cache.rdb\ndir /home/user/benches/develop/config/pids\npidfile /home/user/benches/develop/config/pids/redis_cache.pid\nbind 127.0.0.1\nport 13000\nmaxmemory 737mb\nmaxmemory-policy allkeys-lru\nappendonly no\n\nsave \"\"\n\nYou can modify this maxmemory in this config to increase the maximum memory allocated for caching. We do not recommend modifying anything else.\n\nRefer to the official config documentation to understand more: https://redis.io/docs/management/config-file/\n\nImplementation details\n\nMulti-tenancy\n\nfrappe.cache internally prefixes keys by some site context. Hence calling frappe.cache.set_value(\"key\") from two different sites on the same bench will create two separate entries for each site.\n\nTo see implementation details of this see frappe.cache.make_key function.\n\nComplex Types\n\nFrappe uses pickle module to serialize complex objects like documents in bytes. Hence when using frappe.cache you don't have to worry about serializing/de-serializing values.\n\nRead more about pickling here: https://docs.python.org/3/library/pickle.html\n\nClient Side caching\n\nFrappe implements client-side cache on top of Redis cache inside frappe.local.cache to avoid repeated calls to Redis.\n\nAny repeated calls to Redis within the same request/job return data from the client cache instead of calling Redis again.\n\nRedisWrapper\n\nAll Frappe related changes are made by wrapping the default Redis client and extending the methods. You can find this code in frappe.utils.redis_wrapper the module.",
  "scrapedAt": "2025-10-22T00:02:47.002Z"
}