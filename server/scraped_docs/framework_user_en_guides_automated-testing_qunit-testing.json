{
  "route": "framework/user/en/guides/automated-testing/qunit-testing",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/guides/automated-testing/qunit-testing",
  "title": "You can either write integration tests, or directly write tests in Javascript using QUnit",
  "content": "You can either write integration tests, or directly write tests in Javascript using QUnit\n\nQUnit helps you write UI tests using the QUnit framework and native frappe API. As you might have guessed, this is a much faster way of writing tests.\n\nTest Runner\n\nTo write QUnit based tests, add your tests in the tests/ui folder of your application. Your test files must begin with test_ and end with .js extension.\n\nTo run your files, you can use the Test Runner. The Test Runner gives a user interface to load all your QUnit tests and run them in the browser.\n\nIn the CI, all QUnit tests are run by the Test Runner using frappe/tests/test_test_runner.py\n\nRunning Tests\n\nTo run a Test Runner based test, use the run-ui-tests bench command by passing the name of the file you want to run.\n\nbench run-ui-tests --test frappe/tests/ui/test_list.js\n\nThis will pass the filename to test_test_runner.py that will load the required JS in the browser and execute the tests\n\nDebugging Tests\n\nTo debug a test, you can open it in the Test Runner from your UI and run it manually to see where it is exactly failing.\n\nTest Sequence\n\nIn Frappe UI tests are run in a fixed sequence to ensure dependencies.\n\nThe sequence in which the tests will be run will be in tests/ui/tests.txt\nfile.\n\nRunning All UI Tests\n\nTo run all UI tests together for your app run\n\nbench run-ui-tests --app [app_name]\n\nThis will run all the files in your tests/ui folder one by one.\n\nExample QUnit Test\n\nHere is the example of the To Do test in QUnit\n\nQUnit.test(\"Test quick entry\", function(assert) {\n assert.expect(2);\n let done = assert.async();\n let random_text = frappe.utils.get_random(10);\n\nfrappe.run_serially([\n () => frappe.set_route('List', 'ToDo'),\n () => frappe.new_doc('ToDo'),\n () => frappe.quick_entry.dialog.set_value('description', random_text),\n () => frappe.quick_entry.insert(),\n (doc) => {\n assert.ok(doc && !doc.__islocal);\n return frappe.set_route('Form', 'ToDo', doc.name);\n },\n () => assert.ok(cur_frm.doc.description.includes(random_text)),\n\n// Delete the created ToDo\n () => frappe.tests.click_page_head_item('Menu'),\n () => frappe.tests.click_dropdown_item('Delete'),\n () => frappe.tests.click_page_head_item('Yes'),\n\n() => done()\n ]);\n });\n\nWriting Test Friendly Code with Promises\n\nPromises are a great way to write test-friendly code. If your method calls an aysnchronous call (ajax), then you should return an Promise object. While writing tests, if you encounter a function that does not return a Promise object, you should update the code to return a Promise object.",
  "scrapedAt": "2025-10-22T00:03:32.935Z"
}