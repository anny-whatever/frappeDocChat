{
  "route": "framework/user/en/api/background_jobs",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/api/background_jobs",
  "title": "background_jobs",
  "content": "Frappe ships with a system for running jobs in the background. It is implemented by using the schedule package and a simple long-running infinite while loop.\n\nYou can enqueue a python method to run in the background by using the frappe.enqueue method:\n\ndef long_running_job(param1, param2):\n # expensive tasks\n pass\n\n# directly pass the function\nfrappe.enqueue(long_running_job, queue='short', param1='A', param2='B')\n\n# or pass the full module path as string\nfrappe.enqueue('app.module.folder.long_running_job', queue='short', param1='A', param2='B')\n\nHere are all the possible arguments you can pass to the enqueue:\n\nfrappe.enqueue(\n method, # python function or a module path as string\n queue=\"default\", # one of short, default, long\n timeout=None, # pass timeout manually\n is_async=True, # if this is True, method is run in worker\n now=False, # if this is True, method is run directly (not in a worker) \n job_name=None, # specify a job name\n enqueue_after_commit=False, # enqueue the job after the database commit is done at the end of the request\n at_front=False, # put the job at the front of the queue\n track_job=False, # tracks some metadata in `Background Task` doctype\n **kwargs, # kwargs are passed to the method as arguments\n)\n\nYou can also enqueue a Document method by using frappe.enqueue_doc:\n\nfrappe.enqueue_doc(\n doctype,\n name,\n \"do_something\", # name of the controller method\n queue=\"long\",\n timeout=4000,\n param=\"value\"\n)\n\nQueue\n\nThere are 3 default queues that are configured with the framework: short, default, and long. Each queue has a default timeout as follows:\n\nshort: 300 seconds\ndefault: 300 seconds\nlong: 1500 seconds\n\nYou can also pass a custom timeout to the enqueue method.\n\nCustom Queues\n\nYou can add custom queues by configuring them in [common_site_config.json](https://frappeframework.com/docs/v14/user/en/basics/site_config#common-site-config):\n\n{\n ...\n \"workers\": {\n \"myqueue\": {\n \"timeout\": 5000, # queue timeout\n \"background_workers\": 4, # number of workers for this queue\n } \n }\n}\n\nWorkers\n\nBy default Frappe sets up 3 worker types for consuming from each queue. The default configuration looks like this:\n\nbench worker --queue short\nbench worker --queue default\nbench worker --queue long\n\nIn production these 3 worker processes are replicated to configured number of background workers to handle higher workloads.\n\nNOTE: This way of mapping workers to single queue is just a convention and it's not necessary to follow it.\n\nMulti-queue consumption\n\nYou can specify more than one queue for workers to consume from by specifying a comma separate string of queue names.\n\nExample: If you wanted to combine short and default workers and only use two types of workers instead of default configuration then you can modify your worker configuration like this:\n\nbench worker --queue short,default\nbench worker --queue long\n\nNOTE: The examples shown here are for Procfile format but they can be applied to supervisor or systemd configurations easily too.\n\nBurst Mode using --burst\n\nbench worker --queue short --burst\n\nThis command will spawn a tempoary worker that will start consuming short queue and quit once queue is empty. If you periodically need higher amount of workers then you can use your OS's crontab to setup burst workers at specific times.\n\nScheduler Events\n\nYou can use Scheduler Events for running tasks periodically in the background using the scheduler_events hook.\n\napp/hooks.py\n\nscheduler_events = {\n \"hourly\": [\n # will run hourly\n \"app.scheduled_tasks.update_database_usage\"\n ],\n}\n\napp/scheduled_tasks.py\n\ndef update_database_usage():\n pass\n\n After changing any scheduled events in hooks.py, you need to run bench migrate for changes to take effect.\n\nAvailable Events\n\nhourly, daily, weekly, and monthly\n\nThese events will trigger every hour, day, week, and month respectively.\n* hourly_long, daily_long, weekly_long, monthly_long\n\nSame as above but these jobs are run in the long worker suitable for long-running jobs.\n* all\n\nThe all event is triggered every 4 minutes. This can be configured via the scheduler_interval key in common_site_config.json\n* cron\n\nA valid cron string that can be parsed by croniter.\n\nUsage Examples:\n\nscheduler_events = {\n \"daily\": [\n \"app.scheduled_tasks.manage_recurring_invoices\"\n ],\n \"daily_long\": [\n \"app.scheduled_tasks.take_backups_daily\"\n ],\n \"cron\": {\n \"15 18 * * *\": [\n \"app.scheduled_tasks.delete_all_barcodes_for_users\"\n ],\n \"*/6 * * * *\": [\n \"app.scheduled_tasks.collect_error_snapshots\"\n ],\n \"annual\": [\n \"app.scheduled_tasks.collect_error_snapshots\"\n ]\n }\n}\n\nConfigurable Scheduler Events\n\nOn scenarios that require a user configurable trigger interval, Create a Scheduler Event record and create a Scheduled Job Type entry against that record. This doesn't require scheduler_event hook.\n\nExample:\n\n# Create `Scheduler Event` record\nsch_eve = frappe.new_doc(\"Scheduler Event\")\nsch_eve.scheduled_against = \"Process Payment Reconciliation\"\nsch_eve.save()\n\n# Create `Scheduled Job Type`\njob = frappe.new_doc(\"Scheduled Job Type\")\njob.frequency = \"Cron\"\njob.scheduler_event = sch_eve.name\njob.cron_format = \"0/5 * * * *\" # runs every five minutes\njob.save()\n\nThe Scheduled Job Types trigger interval can be modified later, which persits across bench migration.\n\n The jobs triggered by scheduler are run by Administrator user. This also means any docs you create via scheduled job will be owned by the Administrator user unless specified otherwise.",
  "scrapedAt": "2025-10-22T00:01:41.742Z"
}