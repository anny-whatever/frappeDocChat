{
  "route": "framework/user/en/basics/doctypes/virtual-doctype",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/basics/doctypes/virtual-doctype",
  "title": "virtual-doctype",
  "content": "Virtual DocType is a feature-extension for DocType which allows developers to create DocTypes with custom data sources and DocType controller. The purpose is to define custom DocTypes in the system without creating a table in the database, while utilizing the frontend, resource APIs, and roles and permissions from the framework.\n\nThese Virtual DocTypes function exactly like normal DocTypes in the frontend and are indistinguishable for the end-user, but gives more control to the developer over the DocType's data source. With this, the data source for a Virtual DocType can be anything: an external API, a secondary database, JSON or CSV files, etc. This enables the developers to plug-in database backends other than MariaDB and Postgres, and makes the Frappe Framework even more powerful!\n\nNote: frappe.db.* calls work only with site's database connection. You'll need to implement methods to achieve direct query to data store used by Virtual DocType.\n\nCreating a Virtual DocType\n\nTo create a Virtual DocType, just select the Virtual DocType checkbox while creating the DocType:\n\n \n\nCreating a Custom Controller\n\nAs an example, the following controller code uses a JSON file as the DocType datasource:\n\nclass VirtualDoctype(Document):\n \"\"\"This is a virtual doctype controller for demo purposes.\n\n - It uses a single JSON file on disk as \"backend\".\n - Key is docname and value is the document itself.\n\n Example:\n {\n \"doc1\": {\"name\": \"doc1\", ...}\n \"doc2\": {\"name\": \"doc2\", ...}\n }\n \"\"\"\n\n DATA_FILE = \"data_file.json\"\n\n @staticmethod\n def get_current_data() -> dict[str, dict]:\n \"\"\"Read data from disk\"\"\"\n if not os.path.exists(VirtualDoctype.DATA_FILE):\n return {}\n\n with open(VirtualDoctype.DATA_FILE) as f:\n return json.load(f)\n\n @staticmethod\n def update_data(data: dict[str, dict]) -> None:\n \"\"\"Flush updated data to disk\"\"\"\n with open(VirtualDoctype.DATA_FILE, \"w+\") as data_file:\n json.dump(data, data_file)\n\n def db_insert(self, *args, **kwargs):\n d = self.get_valid_dict(convert_dates_to_str=True)\n\n data = self.get_current_data()\n data[d.name] = d\n\n self.update_data(data)\n\n def load_from_db(self):\n data = self.get_current_data()\n d = data.get(self.name)\n super(Document, self).__init__(d)\n\n def db_update(self, *args, **kwargs):\n # For this example insert and update are same operation,\n # it might be different for you.\n self.db_insert(*args, **kwargs)\n\n def delete(self):\n data = self.get_current_data()\n data.pop(self.name, None)\n self.update_data(data)\n\n @staticmethod\n def get_list(args):\n data = VirtualDoctype.get_current_data()\n return [frappe._dict(doc) for name, doc in data.items()]\n\n @staticmethod\n def get_count(args):\n data = VirtualDoctype.get_current_data()\n return len(data)\n\n @staticmethod\n def get_stats(args):\n return {}\n\nYou can read about the interface requriements and explanation in the interface file. To integrate other datasources with the Virtual DocType, you will need to add controller methods defining the database access.\n\nOutcome\n\nThe frontend for Virtual DocTypes remain unchanged\n\n \n\nAll the /api/resource methods defined by the framework are compatible with Virtual DocTypes.\n\n Added in Version 13",
  "scrapedAt": "2025-10-22T00:01:36.068Z"
}