{
  "route": "framework/user/en/python-api/routing-and-rendering",
  "sourceUrl": "https://docs.frappe.io/framework/user/en/python-api/routing-and-rendering",
  "title": "routing-and-rendering",
  "content": "The user of a web application can visit different URLs like /about, /posts or /api/resources. Each request is handled based on the following request types.\n\nAPI requests that start with /api are handled by rest API handler.\nFile downloads like backups (/backups), public files (/files), and private files (/private/files) are handled separately to respond with a downloadable file.\nWeb page requests like /about, /posts are handled by the website router. This is explained further on this page.\n\nLearn more about API requests and Static Files in detail.\n\nRequest pre-processing\n\nA few things happen before the routing rules are triggered. These include preprocessing the request initializing the recorder and the rate limiter.\n\nPath Resolver\n\nOnce the request reaches to website router from app.py it is passed through the path resolver.\n\nPath resolver does the following operations:\n\nRedirect Resolution\n\nPath resolver tries to resolve any possible redirect for an incoming request path. Path resolver gets redirect rules for website_redirects hook and route redirects from website settings.\n\nRoute Resolution\n\nIf there are no redirects for incoming requests path resolver tries to resolve the route to get the final endpoint based on rules from website\\routing\\rules hook and dynamic route set in documents of DocType with has_web_view enabled.\n\nRenderer Selection\n\nOnce the final endpoint is obtained it is passed through all available Page Renderers to check which page renderer can render the given path. A first page renderer to return True for can_render request will be used to render the path.\n\nPage Renderer\n\nA page renderer takes care of rendering or responding with a page for a given endpoint. A page renderer is implemented using a python class. A page renderer class needs to have two methods i.e., can_render and render.\n\nPath resolver calls can_render to check if a renderer instance can render a particular path.\nOnce a renderer returns True from can_render, it will be that renderer class's responsibility to render the path.\n\nExample page renderer class\n\nfrom frappe.website.page_renderers.base_renderer import BaseRenderer\n\nclass PageRenderer(BaseRenderer):\n def can_render(self):\n return True\n\n def render(self):\n response_html = \"Response\"\n return self.build_response(response_html)\n\nFollowing are the standard page renderers which handle all the generic types of web pages.\n\nStaticPage\n\nUsing StaticPage you can serve PDFs, images, etc., from the www folder of any app installed on the site. Any file that is not one of the following types html, md, js, xml, css, txt or py is considered to be a static file.\nThe preferred way of serving static files would be to add them to the public folder of your frappe app. That way it will be served by NGINX directly leveraging compression and caching while also reducing latency.\n\nTemplatePage\n\nThe TemplatePage looks up the www folder in all apps, if it is an HTML or markdown file, it is returned, in case it is a folder, the index.html or index.md file in the folder is returned.\n\nWebformPage\n\nThe WebformPage tries to render web form in the Web Form list if the request path matches with any of the available Web Form's routes.\n\nDocumentPage\n\nThe DocumentPage tries to render a document template if it is available in /templates folder of the DocType. The template file name should be the same as the DocType name. Example: If you want to add a document template for User doctype, the templates folder of User DocType should have user.html. The folder structure will look like doctype/user/templates/user.html\n\nListPage\n\nIf a DocType has a list template in /templates folder of the DocType, the ListPage will render it. Please check Blog Post templates folder for implementation reference.\n\nPrintPage\n\nThe PrintPage renders a print view for a document. It uses standard print format unless a different print format is set for a DocType via default_print_format.\n\nNotFoundPage\n\nThe NotFoundPage renders a standard not found page and responds with 404 status code.\n\nNotPermittedPage\n\nThe NotPermittedPage renders standard permission denied page with 403 status code.\n\nAdding a custom page renderer\n\nIf you have any other requirements which are not handled by Standard Page renderers a custom page renderer can be added via page_renderer [hook]\n\n# in hooks.py of your custom app\n\npage_renderer = \"path.to.your.custom_page_renderer.CustomPage\"\n\nA Page renderer class needs to have two methods i.e., can_render and render\n\nPath resolver calls can_render to check if a renderer instance can render a particular path.\nOnce a renderer returns True from can_render, it will be that renderer class's responsibility to render the path.\n\nNote: Custom page renderers get priority and it's can_render method will be called before Standard Page Renderers.\n\nExample:\n\nfrom frappe.website.utils import build_response\nfrom frappe.website.page_renderers.base_renderer import BaseRenderer\n\nclass CustomPage(BaseRenderer):\n def can_render(self):\n return True\n\n def render(self):\n response_html = \"Custom Response\"\n return self.build_response(response_html)\n\nNote: You can also extend Standard Page Renderers to override or to use some standard functionalities.",
  "scrapedAt": "2025-10-22T00:01:44.145Z"
}